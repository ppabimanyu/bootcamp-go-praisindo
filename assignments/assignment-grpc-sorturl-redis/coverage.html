
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">boiler-plate/app/api/devrouter.go (0.0%)</option>
				
				<option value="file1">boiler-plate/app/api/middleware.go (0.0%)</option>
				
				<option value="file2">boiler-plate/app/api/router.go (0.0%)</option>
				
				<option value="file3">boiler-plate/app/api/server.go (0.0%)</option>
				
				<option value="file4">boiler-plate/app/appconf/app_config.go (0.0%)</option>
				
				<option value="file5">boiler-plate/app/appconf/auth_config.go (0.0%)</option>
				
				<option value="file6">boiler-plate/app/appconf/config.go (0.0%)</option>
				
				<option value="file7">boiler-plate/app/appconf/customerservice_config.go (0.0%)</option>
				
				<option value="file8">boiler-plate/app/appconf/database_config.go (0.0%)</option>
				
				<option value="file9">boiler-plate/app/appconf/kafka_config.go (0.0%)</option>
				
				<option value="file10">boiler-plate/app/appconf/notificationservice_config.go (0.0%)</option>
				
				<option value="file11">boiler-plate/app/appconf/otp_config.go (0.0%)</option>
				
				<option value="file12">boiler-plate/cmd/boot.go (0.0%)</option>
				
				<option value="file13">boiler-plate/cmd/http.go (0.0%)</option>
				
				<option value="file14">boiler-plate/cmd/root.go (0.0%)</option>
				
				<option value="file15">boiler-plate/internal/base/app/context.go (100.0%)</option>
				
				<option value="file16">boiler-plate/internal/base/handler/base.go (34.9%)</option>
				
				<option value="file17">boiler-plate/internal/base/handler/check.go (0.0%)</option>
				
				<option value="file18">boiler-plate/internal/submissions/domain/submission.go (100.0%)</option>
				
				<option value="file19">boiler-plate/internal/submissions/domain/submission_request.go (91.7%)</option>
				
				<option value="file20">boiler-plate/internal/submissions/handler/handler.go (100.0%)</option>
				
				<option value="file21">boiler-plate/internal/submissions/mocks/Service.go (73.8%)</option>
				
				<option value="file22">boiler-plate/internal/submissions/mocks/SubmissionsRepository.go (68.2%)</option>
				
				<option value="file23">boiler-plate/internal/submissions/repository/repository.go (100.0%)</option>
				
				<option value="file24">boiler-plate/internal/submissions/service/service.go (98.7%)</option>
				
				<option value="file25">boiler-plate/internal/users/domain/users.go (100.0%)</option>
				
				<option value="file26">boiler-plate/internal/users/handler/handler.go (100.0%)</option>
				
				<option value="file27">boiler-plate/internal/users/mocks/Service.go (58.8%)</option>
				
				<option value="file28">boiler-plate/internal/users/mocks/UsersRepository.go (73.1%)</option>
				
				<option value="file29">boiler-plate/internal/users/repository/repository.go (100.0%)</option>
				
				<option value="file30">boiler-plate/internal/users/service/service.go (100.0%)</option>
				
				<option value="file31">boiler-plate/main.go (0.0%)</option>
				
				<option value="file32">boiler-plate/pkg/broker/kafkaservice/kafka_service.go (0.0%)</option>
				
				<option value="file33">boiler-plate/pkg/db/connection.go (0.0%)</option>
				
				<option value="file34">boiler-plate/pkg/db/mongodb.go (0.0%)</option>
				
				<option value="file35">boiler-plate/pkg/db/pagination.go (83.3%)</option>
				
				<option value="file36">boiler-plate/pkg/errs/error.go (13.3%)</option>
				
				<option value="file37">boiler-plate/pkg/errs/factory.go (44.4%)</option>
				
				<option value="file38">boiler-plate/pkg/errs/stack.go (87.9%)</option>
				
				<option value="file39">boiler-plate/pkg/exception/exception.go (57.1%)</option>
				
				<option value="file40">boiler-plate/pkg/filelog/filelog.go (0.0%)</option>
				
				<option value="file41">boiler-plate/pkg/filevalidation/filevalidation.go (0.0%)</option>
				
				<option value="file42">boiler-plate/pkg/getfilter/bindingfilter.go (0.0%)</option>
				
				<option value="file43">boiler-plate/pkg/getfilter/filterparser.go (0.0%)</option>
				
				<option value="file44">boiler-plate/pkg/getfilter/getfilter.go (0.0%)</option>
				
				<option value="file45">boiler-plate/pkg/httpclient/httpcall.go (0.0%)</option>
				
				<option value="file46">boiler-plate/pkg/httputils/client.go (0.0%)</option>
				
				<option value="file47">boiler-plate/pkg/httputils/response.go (58.3%)</option>
				
				<option value="file48">boiler-plate/pkg/memstorage/mem_storage.go (0.0%)</option>
				
				<option value="file49">boiler-plate/pkg/migration/migration.go (0.0%)</option>
				
				<option value="file50">boiler-plate/pkg/password/password.go (0.0%)</option>
				
				<option value="file51">boiler-plate/pkg/responsehelper/responsehelper.go (0.0%)</option>
				
				<option value="file52">boiler-plate/pkg/server/app.go (0.0%)</option>
				
				<option value="file53">boiler-plate/pkg/utils/network/ip.go (0.0%)</option>
				
				<option value="file54">boiler-plate/pkg/utils/phonenumber/phone_number.go (0.0%)</option>
				
				<option value="file55">boiler-plate/pkg/utils/pointer/pointer.go (0.0%)</option>
				
				<option value="file56">boiler-plate/pkg/utils/rand/rand.go (0.0%)</option>
				
				<option value="file57">boiler-plate/pkg/utils/text/string.go (0.0%)</option>
				
				<option value="file58">boiler-plate/pkg/xvalidator/validator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "boiler-plate/app/appconf"
        "boiler-plate/internal/base/app"
        "boiler-plate/pkg/server"
        "net/http"
)

func (h *HttpServe) setupDevRouter(conf *appconf.Config) <span class="cov0" title="0">{
        h.router.GET("/api/v2/health-check", h.base.GuestRunAction(func(ctx *app.Context) *server.ResponseInterface </span><span class="cov0" title="0">{
                return &amp;server.ResponseInterface{
                        Status: http.StatusOK,
                        Data: map[string]interface{}{
                                "status":  "ok",
                                "service": conf.AppEnvConfig.AppName,
                        },
                }
        }</span>))
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "boiler-plate/pkg/getfilter"
        "net/http"

        "github.com/gin-gonic/gin"
)

func ResponseHeaderFormat() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span>{<span class="cov0" title="0">
        }</span>
}

func AuthMiddle() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{

                username, password, ok := c.Request.BasicAuth()
                if !ok </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "status":  http.StatusUnauthorized,
                                "message": "Authorization basic token required",
                        })
                        return
                }</span>
                <span class="cov0" title="0">const (
                        expectedUsername = "user"
                        expectedPassword = "pass"
                )
                isValid := (username == expectedUsername) &amp;&amp; (password == expectedPassword)
                if !isValid </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "status":  http.StatusUnauthorized,
                                "message": "User password invalid",
                        })
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
}

func FilterMiddle() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{

                err := getfilter.Handle(c)
                if err </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusNotAcceptable, gin.H{
                                "status":  http.StatusNotAcceptable,
                                "message": "query invalid",
                        })
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "fmt"

        "boiler-plate/internal/base/handler"
)

func (h *HttpServe) setupUsersRouter() <span class="cov0" title="0">{
        h.GuestRoute("GET", "/users", h.UsersHandler.Find)
        h.GuestRoute("POST", "/users", h.UsersHandler.Create)
        h.GuestRoute("PUT", "/users/:id", h.UsersHandler.Update)
        h.GuestRoute("GET", "/users/:id", h.UsersHandler.Detail)
        h.GuestRoute("DELETE", "/users/:id", h.UsersHandler.Delete)
        h.GuestRoute("GET", "/users/:id/submissions", h.SubmissionsHandler.FindByUser)

        h.GuestRoute("GET", "/submissions", h.SubmissionsHandler.Find)
        h.GuestRoute("POST", "/submissions", h.SubmissionsHandler.Create)
        h.GuestRoute("GET", "/submissions/:id", h.SubmissionsHandler.Detail)
        h.GuestRoute("DELETE", "/submissions/:id", h.SubmissionsHandler.Delete)
}</span>

func (h *HttpServe) UserRoute(method, path string, f handler.HandlerFnInterface) <span class="cov0" title="0">{
        userRoute := h.router.Group("/api/v2")
        switch method </span>{
        case "GET":<span class="cov0" title="0">
                userRoute.GET(path, h.base.UserRunAction(f))</span>
        case "POST":<span class="cov0" title="0">
                userRoute.POST(path, h.base.UserRunAction(f))</span>
        case "PUT":<span class="cov0" title="0">
                userRoute.PUT(path, h.base.UserRunAction(f))</span>
        case "DELETE":<span class="cov0" title="0">
                userRoute.DELETE(path, h.base.UserRunAction(f))</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf(":%s method not allow", method))</span>
        }
}

func (h *HttpServe) GuestRoute(method, path string, f handler.HandlerFnInterface) <span class="cov0" title="0">{
        guestRoute := h.router.Group("/api/v2")
        switch method </span>{
        case "GET":<span class="cov0" title="0">
                guestRoute.GET(path, AuthMiddle(), h.base.GuestRunAction(f))</span>
        case "POST":<span class="cov0" title="0">
                guestRoute.POST(path, AuthMiddle(), h.base.GuestRunAction(f))</span>
        case "PUT":<span class="cov0" title="0">
                guestRoute.PUT(path, AuthMiddle(), h.base.GuestRunAction(f))</span>
        case "DELETE":<span class="cov0" title="0">
                guestRoute.DELETE(path, AuthMiddle(), h.base.GuestRunAction(f))</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf(":%s method not allow", method))</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "boiler-plate/app/appconf"
        "fmt"
        "os"
        "strings"

        "boiler-plate/internal/base/handler"
        subHandler "boiler-plate/internal/submissions/handler"
        tempHandler "boiler-plate/internal/users/handler"
        "boiler-plate/pkg/server"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        gintrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/gin-gonic/gin"
)

type HttpServe struct {
        router             *gin.Engine
        base               *handler.BaseHTTPHandler
        UsersHandler       *tempHandler.HTTPHandler
        SubmissionsHandler *subHandler.HTTPHandler
}

func (h *HttpServe) Run(config *appconf.Config) error <span class="cov0" title="0">{
        h.setupUsersRouter()
        h.setupDevRouter(config)
        h.base.Handlers = h

        //if h.base.IsStaging() {
        //        h.setupDevRouter()
        //}

        return h.router.Run(fmt.Sprintf(":%s", config.AppEnvConfig.HttpPort))
}</span>

func New(
        appName string, base *handler.BaseHTTPHandler,
        Users *tempHandler.HTTPHandler,
        Submissions *subHandler.HTTPHandler,
) server.App <span class="cov0" title="0">{

        if os.Getenv("APP_ENV") != "production" </span><span class="cov0" title="0">{
                if os.Getenv("DEV_SHOW_ROUTE") == "False" </span><span class="cov0" title="0">{
                        gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) </span>{<span class="cov0" title="0">

                        }</span>
                } else<span class="cov0" title="0"> {
                        gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) </span><span class="cov0" title="0">{
                                fmt.Printf("Route: %-6s %-25s --&gt; %s (%d handlers)\n",
                                        httpMethod, absolutePath, handlerName[strings.LastIndex(handlerName, "/")+1:], nuHandlers)

                        }</span>
                }
        }

        <span class="cov0" title="0">pathNamer := func(c *gin.Context) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s %s%s", c.Request.Method, c.Request.Host, c.Request.RequestURI)
        }</span>

        <span class="cov0" title="0">r := gin.New()
        r.Use(gintrace.Middleware(appName, gintrace.WithResourceNamer(pathNamer)))
        r.Use(ResponseHeaderFormat())
        r.Use(cors.New(cors.Config{
                AllowOrigins:     base.AppConfig.AppEnvConfig.AllowOrigins,
                AllowMethods:     base.AppConfig.AppEnvConfig.AllowMethods,
                AllowHeaders:     base.AppConfig.AppEnvConfig.AllowHeaders,
                AllowCredentials: true,
        }))

        return &amp;HttpServe{
                router:             r,
                base:               base,
                UsersHandler:       Users,
                SubmissionsHandler: Submissions,
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package appconf

import (
        "github.com/sirupsen/logrus"
        "os"
        "strconv"
        "strings"
)

type AppConfig struct {
        AppEnv       string
        AppDebug     string
        AppVersion   string   `validate:"required,startswith=v,alphanum" name:"APP_VERSION"`
        AppName      string   `validate:"required" name:"APP_NAME"`
        HttpPort     string   `validate:"required,number" name:"HTTP_PORT"`
        AllowOrigins []string `validate:"required" name:"ALLOW_ORIGINS"`
        AllowMethods []string `validate:"required" name:"ALLOW_METHODS"`
        AllowHeaders []string `validate:"required" name:"ALLOW_HEADERS"`
        FilePath     string   `validate:"required" name:"FILE_PATH"`
        FileMaxSize  int      `validate:"required,number" name:"FILE_MAX_SIZE"`
}

func AppConfigInit() *AppConfig <span class="cov0" title="0">{
        maxSize := os.Getenv("FILE_MAX_SIZE")
        maxSizeInt, err := strconv.Atoi(maxSize)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Panicf("FILE_MAX_SIZE must be int")
        }</span>
        <span class="cov0" title="0">return &amp;AppConfig{
                AppEnv:       os.Getenv("APP_ENV"),
                AppDebug:     os.Getenv("APP_DEBUG"),
                AppVersion:   os.Getenv("APP_VERSION"),
                AppName:      os.Getenv("APP_NAME"),
                HttpPort:     os.Getenv("HTTP_PORT"),
                AllowOrigins: strings.Split(os.Getenv("ALLOW_ORIGINS"), ","),
                AllowMethods: strings.Split(os.Getenv("ALLOW_METHODS"), ","),
                AllowHeaders: strings.Split(os.Getenv("ALLOW_HEADERS"), ","),
                FilePath:     os.Getenv("FILE_PATH"),
                FileMaxSize:  maxSizeInt,
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package appconf

import "os"

type AuthConfig struct {
        JwtSecretAccessToken []byte `validate:"required" name:"JWT_SECRET_ACCESS_TOKEN"`
}

func AuthConfigInit() *AuthConfig <span class="cov0" title="0">{
        return &amp;AuthConfig{
                JwtSecretAccessToken: []byte(os.Getenv("JWT_SECRET_ACCESS_TOKEN")),
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package appconf

import (
        "boiler-plate/pkg/xvalidator"
        "fmt"
        "github.com/sirupsen/logrus"
        "os"
)

type Config struct {
        AppEnvConfig              *AppConfig
        DatabaseConfig            *DatabaseConfig
        KafkaConfig               *KafkaConfig
        AuthConfig                *AuthConfig
        NotificationServiceConfig *NotificationServiceConfig
        OTPConfig                 *OTPConfig
        CustomerServiceConfig     *CustomerServiceConfig
}

func (c Config) IsStaging() bool <span class="cov0" title="0">{
        return c.AppEnvConfig.AppEnv != "production"
}</span>

func (c Config) IsProd() bool <span class="cov0" title="0">{
        return c.AppEnvConfig.AppEnv == "production"
}</span>

func (c Config) IsDebug() bool <span class="cov0" title="0">{
        return c.AppEnvConfig.AppDebug == "True"
}</span>

func InitAppConfig(validate *xvalidator.Validator) *Config <span class="cov0" title="0">{

        c := Config{
                AppEnvConfig:              AppConfigInit(),
                DatabaseConfig:            DatabaseConfigInit(),
                KafkaConfig:               KafkaConfigInit(),
                AuthConfig:                AuthConfigInit(),
                NotificationServiceConfig: NotificationServiceConfigInit(),
                OTPConfig:                 OTPConfigInit(),
                CustomerServiceConfig:     CustomerServiceConfigInit(),
        }

        // NOTIFICATION SERVICE CONFIG
        //c.SendEmailOTPURL = os.Getenv("NOTIFICATION_SERVICE_SEND_EMAIL_URL")
        //c.SendSMSOTPURL = os.Getenv("NOTIFICATION_SERVICE_SEND_SMS_URL")
        //c.TemplateEmailOTP = os.Getenv("OTP_EMAIL_TEMPLATE_ID")
        //c.TemplateSMSOTP = os.Getenv("OTP_SMS_TEMPLATE_ID")
        //c.NotificationServiceAPIKey = os.Getenv("NOTIFICATION_SERVICE_API_KEY")

        // OTP CONFIG
        //emailOTPExpired, err := time.ParseDuration(os.Getenv("EMAIL_OTP_EXPIRED"))
        //if err != nil {
        //        logrus.Fatalf("invalid EMAIL_OTP_EXPIRED: %v", err)
        //}
        //c.EmailOTPExpired = emailOTPExpired
        //phoneOTPExpired, err := time.ParseDuration(os.Getenv("SMS_OTP_EXPIRED"))
        //if err != nil {
        //        logrus.Fatalf("invalid SMS_OTP_EXPIRED: %v", err)
        //}
        //c.PhoneOTPExpired = phoneOTPExpired

        // KAFKA CONFIG
        //c.KafkaSecurityProtocol = os.Getenv("KAFKA_SECURITY_PROTOCOL")
        //c.Username = os.Getenv("KAFKA_USERNAME")
        //c.Password = os.Getenv("KAFKA_PASSWORD")
        //brokers := strings.Split(os.Getenv("KAFKA_BROKERS"), ",")
        //if len(brokers) == 0 {
        //        brokers = nil
        //}
        //c.Brokers = brokers
        //c.GroupID = os.Getenv("KAFKA_GROUP_ID")
        //c.UpdateCustomerTopic = os.Getenv("KAFKA_UPDATE_CUSTOMER_TOPIC")

        // CUSTOMER SERVICE CONFIG
        //c.CustomerSvcGetDetailInvestorURL = os.Getenv("CUSTOMER_SERVICE_GET_DETAIL_INVESTOR_URL")
        //c.CustomerSvcAPIKey = os.Getenv("CUSTOMER_SERVICE_API_KEY")

        //c.TemplateSMSOTPRegis = os.Getenv("SEND_OTP_SMS_TEMPLATE_REGIS_ID")
        //OTPRegisExpired, err := time.ParseDuration(os.Getenv("SMS_OTP_REGIS_EXPIRED"))
        //if err != nil {
        //        logrus.Fatalf("Invalid SMS_OTP_REGIS_EXPIRED: %v", err)
        //}
        //logrus.Info(OTPRegisExpired)
        //c.OTPRegisExpired = OTPRegisExpired
        //c.TemplateEmailOTPRegis = os.Getenv("SEND_OTP_EMAIL_TEMPLATE_REGIS_ID")

        // JWT ACCESS TOKEN
        //c.JWTSecretAccessToken = []byte(os.Getenv("JWT_SECRET_ACCESS_TOKEN"))
        errs := validate.Struct(c)
        if errs != nil </span><span class="cov0" title="0">{
                for _, e := range errs </span><span class="cov0" title="0">{
                        logrus.Error(fmt.Sprintf("Failed to load env: %s", e))
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
        <span class="cov0" title="0">return &amp;c</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package appconf

import "os"

type CustomerServiceConfig struct {
        CustomerSvcGetDetailInvestorURL string `validate:"required" name:"CUSTOMER_SERVICE_GET_DETAIL_INVESTOR_URL"`
        CustomerSvcAPIKey               string `validate:"required" name:"CUSTOMER_SERVICE_API_KEY"`
}

func CustomerServiceConfigInit() *CustomerServiceConfig <span class="cov0" title="0">{
        return &amp;CustomerServiceConfig{
                CustomerSvcGetDetailInvestorURL: os.Getenv("CUSTOMER_SERVICE_GET_DETAIL_INVESTOR_URL"),
                CustomerSvcAPIKey:               os.Getenv("CUSTOMER_SERVICE_API_KEY"),
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package appconf

import (
        "os"
        "strconv"
)

type DatabaseConfig struct {
        Dbservice  string `validate:"required,eq=postgres|eq=mysql|eq=sqlserver" name:"DB_CONNECTION"`
        Dbhost     string `validate:"required" name:"DB_HOST"`
        Dbport     int    `validate:"required" name:"DB_PORT"`
        Dbdatabase string `validate:"required" name:"DB_DATABASE"`
        Dbuser     string `validate:"required" name:"DB_USERNAME"`
        Dbpassword string `validate:"required" name:"DB_PASSWORD"`
        Dbprefix   string `validate:"required" name:"DB_PREFIX"`
}

func DatabaseConfigInit() *DatabaseConfig <span class="cov0" title="0">{
        port, _ := strconv.Atoi(os.Getenv("DB_PORT"))
        return &amp;DatabaseConfig{
                Dbservice:  os.Getenv("DB_CONNECTION"),
                Dbhost:     os.Getenv("DB_HOST"),
                Dbport:     port,
                Dbdatabase: os.Getenv("DB_DATABASE"),
                Dbuser:     os.Getenv("DB_USERNAME"),
                Dbpassword: os.Getenv("DB_PASSWORD"),
                Dbprefix:   os.Getenv("DB_PREFIX"),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package appconf

import (
        "os"
        "strings"
)

type KafkaConfig struct {
        KafkaSecurityProtocol    string   `validate:"required,eq=SASL_SSL|eq=SASL_PLAIN|eq=PLAIN" name:"KAFKA_SECURITY_PROTOCOL"`
        KafkaUsername            string   `validate:"required" name:"KAFKA_USERNAME"`
        KafkaPassword            string   `validate:"required" name:"KAFKA_PASSWORD"`
        KafkaBroker              []string `validate:"required" name:"KAFKA_BROKER"`
        KafkaGroupId             string   `validate:"required" name:"KAFKA_GROUP_ID"`
        KafkaUpdateCustomerTopic string   `validate:"required" name:"KAFKA_UPDATE_CUSTOMER_TOPIC"`
}

func KafkaConfigInit() *KafkaConfig <span class="cov0" title="0">{
        brokers := strings.Split(os.Getenv("KAFKA_BROKERS"), ",")
        if len(brokers) == 0 </span><span class="cov0" title="0">{
                brokers = nil
        }</span>
        <span class="cov0" title="0">return &amp;KafkaConfig{
                KafkaSecurityProtocol:    os.Getenv("KAFKA_SECURITY_PROTOCOL"),
                KafkaUsername:            os.Getenv("KAFKA_USERNAME"),
                KafkaPassword:            os.Getenv("KAFKA_PASSWORD"),
                KafkaBroker:              brokers,
                KafkaGroupId:             os.Getenv("KAFKA_GROUP_ID"),
                KafkaUpdateCustomerTopic: os.Getenv("KAFKA_UPDATE_CUSTOMER_TOPIC"),
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package appconf

import "os"

type NotificationServiceConfig struct {
        SendEmailOTPURL           string `validate:"required" name:"NOTIFICATION_SERVICE_SEND_EMAIL_URL"`
        SendSMSOTPURL             string `validate:"required" name:"NOTIFICATION_SERVICE_SEND_SMS_URL"`
        TemplateEmailOTP          string `validate:"required" name:"OTP_EMAIL_TEMPLATE_ID"`
        TemplateSMSOTP            string `validate:"required" name:"OTP_SMS_TEMPLATE_ID"`
        NotificationServiceAPIKey string `validate:"required" name:"NOTIFICATION_SERVICE_API_KEY"`
}

func NotificationServiceConfigInit() *NotificationServiceConfig <span class="cov0" title="0">{
        return &amp;NotificationServiceConfig{
                SendEmailOTPURL:           os.Getenv("NOTIFICATION_SERVICE_SEND_EMAIL_URL"),
                SendSMSOTPURL:             os.Getenv("NOTIFICATION_SERVICE_SEND_SMS_URL"),
                TemplateEmailOTP:          os.Getenv("OTP_EMAIL_TEMPLATE_ID"),
                TemplateSMSOTP:            os.Getenv("OTP_SMS_TEMPLATE_ID"),
                NotificationServiceAPIKey: os.Getenv("NOTIFICATION_SERVICE_API_KEY"),
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package appconf

import (
        "github.com/sirupsen/logrus"
        "os"
        "time"
)

type OTPConfig struct {
        EmailOTPExpired       time.Duration `validate:"required" name:"EMAIL_OTP_EXPIRED"`
        PhoneOTPExpired       time.Duration `validate:"required" name:"SMS_OTP_EXPIRED"`
        TemplateSMSOTPRegis   string        `validate:"required" name:"SEND_OTP_SMS_TEMPLATE_REGIS_ID"`
        OTPRegisExpired       time.Duration `validate:"required" name:"SMS_OTP_REGIS_EXPIRED"`
        TemplateEmailOTPRegis string        `validate:"required" name:"SEND_OTP_EMAIL_TEMPLATE_REGIS_ID"`
}

func OTPConfigInit() *OTPConfig <span class="cov0" title="0">{
        emailOTPExpired, err := time.ParseDuration(os.Getenv("EMAIL_OTP_EXPIRED"))
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("invalid EMAIL_OTP_EXPIRED: %v", err)
        }</span>
        <span class="cov0" title="0">phoneOTPExpired, err := time.ParseDuration(os.Getenv("SMS_OTP_EXPIRED"))
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("invalid SMS_OTP_EXPIRED: %v", err)
        }</span>
        <span class="cov0" title="0">OTPRegisExpired, err := time.ParseDuration(os.Getenv("SMS_OTP_REGIS_EXPIRED"))
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Invalid SMS_OTP_REGIS_EXPIRED: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;OTPConfig{
                EmailOTPExpired:       emailOTPExpired,
                PhoneOTPExpired:       phoneOTPExpired,
                TemplateEmailOTPRegis: os.Getenv("SEND_OTP_EMAIL_TEMPLATE_REGIS_ID"),
                OTPRegisExpired:       OTPRegisExpired,
                TemplateSMSOTPRegis:   os.Getenv("SEND_OTP_SMS_TEMPLATE_REGIS_ID"),
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cmd

import (
        "boiler-plate/internal/base/handler"
        "fmt"
        "io"
        "log"
        "os"

        appConfiguration "boiler-plate/app/appconf"
        subHandler "boiler-plate/internal/submissions/handler"
        SubmissionsRepo "boiler-plate/internal/submissions/repository"
        SubmissionsService "boiler-plate/internal/submissions/service"
        tempHandler "boiler-plate/internal/users/handler"
        UsersRepo "boiler-plate/internal/users/repository"
        UsersService "boiler-plate/internal/users/service"
        "boiler-plate/pkg/db"
        "boiler-plate/pkg/httpclient"
        "boiler-plate/pkg/migration"
        "boiler-plate/pkg/xvalidator"

        "github.com/go-playground/validator/v10"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

var (
        appConf            *appConfiguration.Config
        baseHandler        *handler.BaseHTTPHandler
        UsersHandler       *tempHandler.HTTPHandler
        SubmissionsHandler *subHandler.HTTPHandler
        sqlClientRepo      *db.SQLClientRepository
        validate           *validator.Validate
        httpClient         httpclient.Client
        xvalidate          *xvalidator.Validator
)

func initHttpclient() <span class="cov0" title="0">{
        httpClientFactory := httpclient.New()
        httpClient = httpClientFactory.CreateClient()
}</span>

func initHTTP() <span class="cov0" title="0">{
        initValidator()
        appConf = appConfiguration.InitAppConfig(xvalidate)
        initInfrastructure(appConf)

        // appConf.MysqlTZ = postgresClientRepo.TZ

        baseHandler = handler.NewBaseHTTPHandler(sqlClientRepo.DB, appConf, sqlClientRepo, httpClient)

        UsersRepo := UsersRepo.NewRepository(sqlClientRepo.DB, sqlClientRepo)
        SubsRepo := SubmissionsRepo.NewRepository(sqlClientRepo.DB, sqlClientRepo)

        UsersService := UsersService.NewService(appConf, UsersRepo, SubsRepo, sqlClientRepo.DB, validate)
        SubsService := SubmissionsService.NewService(appConf, SubsRepo, sqlClientRepo.DB, validate)
        UsersHandler = tempHandler.NewHTTPHandler(baseHandler, UsersService)
        SubmissionsHandler = subHandler.NewHTTPHandler(baseHandler, SubsService)

}</span>

func initInfrastructure(config *appConfiguration.Config) <span class="cov0" title="0">{
        initSQL(config)
        initHttpclient()
        initLog()
}</span>
func initValidator() <span class="cov0" title="0">{
        validate = validator.New()
        xvalidate = xvalidator.NewValidator()
}</span>
func isProd() bool <span class="cov0" title="0">{
        return os.Getenv("APP_ENV") == "production"
}</span>

func initLog() <span class="cov0" title="0">{
        lv := os.Getenv("LOG_LEVEL_DEV")
        level := logrus.InfoLevel
        switch lv </span>{
        case "PanicLevel":<span class="cov0" title="0">
                level = logrus.PanicLevel</span>
        case "FatalLevel":<span class="cov0" title="0">
                level = logrus.FatalLevel</span>
        case "ErrorLevel":<span class="cov0" title="0">
                level = logrus.ErrorLevel</span>
        case "WarnLevel":<span class="cov0" title="0">
                level = logrus.WarnLevel</span>
        case "InfoLevel":<span class="cov0" title="0">
                level = logrus.InfoLevel</span>
        case "DebugLevel":<span class="cov0" title="0">
                level = logrus.DebugLevel</span>
        case "TraceLevel":<span class="cov0" title="0">
                level = logrus.TraceLevel</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">if isProd() </span><span class="cov0" title="0">{
                logrus.SetFormatter(&amp;logrus.JSONFormatter{})
                logrus.SetLevel(logrus.WarnLevel)
                logrus.SetOutput(os.Stdout)
        }</span> else<span class="cov0" title="0"> {
                logrus.SetFormatter(&amp;logrus.JSONFormatter{PrettyPrint: true})
                if lv == "" &amp;&amp; os.Getenv("APP_DEBUG") == "True" </span><span class="cov0" title="0">{
                        level = logrus.DebugLevel
                }</span>
                <span class="cov0" title="0">logrus.SetLevel(level)
                // logrus.SetFormatter()
                if os.Getenv("DEV_FILE_LOG") == "True" </span><span class="cov0" title="0">{
                        logfile, err := os.OpenFile("log/app.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0755)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("error opening file : %v", err)
                        }</span>

                        <span class="cov0" title="0">mw := io.MultiWriter(os.Stdout, logfile)
                        logrus.SetOutput(mw)</span>
                } else<span class="cov0" title="0"> {
                        logrus.SetOutput(os.Stdout)
                }</span>
        }
}

func initSQL(config *appConfiguration.Config) <span class="cov0" title="0">{

        //var gConfig *gorm.Config
        gConfig := &amp;gorm.Config{}
        if os.Getenv("DEV_SHOW_QUERY") == "true" </span><span class="cov0" title="0">{
                showQuery := logger.New(
                        log.New(os.Stdout, "\r\n", log.LstdFlags),
                        logger.Config{
                                LogLevel: logger.Info,
                        })
                gConfig.Logger = showQuery
        }</span> else<span class="cov0" title="0"> {
                gConfig.Logger = logger.Default.LogMode(logger.Silent)
        }</span>

        <span class="cov0" title="0">sqlClientRepo, _ = db.NewSQLClientRepository(config, gConfig)
        if config.IsStaging() </span><span class="cov0" title="0">{
                migration.Initmigrate(sqlClientRepo.DB)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "os"
        "os/signal"
        "syscall"

        "boiler-plate/app/api"

        "github.com/pkg/errors"
        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
)

var HttpCmd = &amp;cobra.Command{
        Use:   "http serve",
        Short: "Run Http API",
        Long:  "Run Http API",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                initHTTP()

                // running open telemetry
                // cleanup := initTracer()
                // defer cleanup(context.Background())
                app := api.New(appConf.AppEnvConfig.AppName, baseHandler, UsersHandler, SubmissionsHandler)

                echan := make(chan error)
                go func() </span><span class="cov0" title="0">{
                        echan &lt;- app.Run(appConf)
                }</span>()

                //go func() {
                //        if err := serverio.Serve(); err != nil {
                //                logrus.Fatalf("socketio listen error: %s\n", err)
                //        }
                //}()
                //defer serverio.Close()

                <span class="cov0" title="0">term := make(chan os.Signal, 1)
                signal.Notify(term, os.Interrupt, syscall.SIGTERM)

                select </span>{
                case &lt;-term:<span class="cov0" title="0">
                        logrus.Infoln("signal terminated detected")
                        return nil</span>
                case err := &lt;-echan:<span class="cov0" title="0">
                        return errors.Wrap(err, "service runtime error")</span>
                }
        },
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmd

import (
        "log"
        "os"

        "github.com/joho/godotenv"
        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
)

var rootCmd = &amp;cobra.Command{
        Use:   "Go Simple API",
        Short: "Go Simple API / Service Demo",
        Long:  "Go Simple API / Service Demo HTTP &amp; GRPC API &amp; Kafka",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                _ = cmd.Help()
        }</span>,
}

// register command
func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(HttpCmd)

        // load environment variable
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                if os.Getenv("APP_ENV") == "development" </span><span class="cov0" title="0">{
                        logrus.Println("unable to load environment variable", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        // fin, err := os.Open("./.env.example")
                        // if err != nil {
                        //         log.Fatal(err)
                        // }
                        // defer fin.Close()

                        fout, err := os.Create("./.env")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        <span class="cov0" title="0">defer fout.Close()</span>

                        // _, err = io.Copy(fout, fin)

                        // if err != nil {
                        //         logrus.Warningln("Can't find env.file. To use system's env vars for now")s
                        // }
                }
        }
}
func Execute() error <span class="cov0" title="0">{
        cmd, _, err := rootCmd.Find(os.Args[1:])

        if err == nil &amp;&amp; cmd.Use == rootCmd.Use &amp;&amp; cmd.Flags().Parse(os.Args[1:]) != pflag.ErrHelp </span><span class="cov0" title="0">{
                args := append([]string{"http"}, os.Args[1:]...)
                rootCmd.SetArgs(args)
        }</span>

        <span class="cov0" title="0">return rootCmd.Execute()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package app

import (
        "boiler-plate/app/appconf"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type Context struct {
        *gin.Context
        Request   *http.Request
        AppConfig *appconf.Config
        APIReqID  string
}

func NewContext(c *gin.Context, conf *appconf.Config) *Context <span class="cov8" title="1">{

        xReqID := c.GetHeader("X-API-Request-ID")

        if xReqID == "" </span><span class="cov8" title="1">{
                xReqID = uuid.NewString()
        }</span>

        <span class="cov8" title="1">ctx := &amp;Context{
                Context:   c,
                Request:   c.Request,
                AppConfig: conf,
                APIReqID:  xReqID,
        }

        return ctx</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handler

import (
        "fmt"
        "net/http"
        "time"

        baseModel "boiler-plate/pkg/db"
        "boiler-plate/pkg/httpclient"

        "github.com/sirupsen/logrus"
        "gorm.io/gorm"

        "boiler-plate/app/appconf"
        "boiler-plate/internal/base/app"
        "boiler-plate/pkg/server"

        "github.com/gin-gonic/gin"
)

type HandlerFn func(ctx *app.Context) *server.Response
type HandlerFnInterface func(ctx *app.Context) *server.ResponseInterface

type BaseHTTPHandler struct {
        Handlers   interface{}
        DB         *gorm.DB
        AppConfig  *appconf.Config
        BaseModel  *baseModel.SQLClientRepository
        HttpClient httpclient.Client
}

func NewBaseHTTPHandler(
        db *gorm.DB,
        appConfig *appconf.Config,
        baseModel *baseModel.SQLClientRepository,
        httpClient httpclient.Client,
) *BaseHTTPHandler <span class="cov8" title="1">{
        return &amp;BaseHTTPHandler{
                DB:         db,
                AppConfig:  appConfig,
                BaseModel:  baseModel,
                HttpClient: httpClient,
        }
}</span>

// Handler Basic Method ======================================================================================================

func (b BaseHTTPHandler) AsJsonInterface(ctx *app.Context, status int, data interface{}) *server.ResponseInterface <span class="cov8" title="1">{

        return &amp;server.ResponseInterface{
                Status: status,
                Data:   data,
        }
}</span>

// ThrowExceptionJson for some exception not handle in Yii2 framework
func (b BaseHTTPHandler) ThrowExceptionJson(ctx *app.Context, status, code int, name, message string) *server.Response <span class="cov0" title="0">{
        return &amp;server.Response{
                Status:  status,
                Message: "",
                Log:     nil,
        }
}</span>

func (b BaseHTTPHandler) UserAuthentication(c *gin.Context) (*app.Context, error) <span class="cov0" title="0">{
        return app.NewContext(c, b.AppConfig), nil
}</span>

func (b BaseHTTPHandler) UserRunAction(handler HandlerFnInterface) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                ctx, err := b.UserAuthentication(c)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorln(fmt.Sprintf("REQUEST ID: %s , message: Unauthorized", ctx.APIReqID))
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "status":  http.StatusUnauthorized,
                                "message": "Unauthorized",
                                "data":    err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err0 := recover(); err0 != nil </span><span class="cov0" title="0">{
                                logrus.Errorln(err0)
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "status":  http.StatusInternalServerError,
                                        "message": "Request is halted unexpectedly, please contact the administrator.",
                                        "data":    nil,
                                })
                        }</span>
                }()

                // Execute handler
                <span class="cov0" title="0">resp := handler(ctx)
                httpStatus := resp.Status

                if resp.Data == nil </span><span class="cov0" title="0">{
                        c.Status(httpStatus)
                        return
                }</span>
                <span class="cov0" title="0">end := time.Now().Sub(start)
                logrus.Infoln(fmt.Sprintf("REQUEST ID: %s , LATENCY: %vms", ctx.APIReqID, end.Milliseconds()))
                c.JSON(httpStatus, resp.Data)</span>

        }
}

func (b BaseHTTPHandler) GuestAuthentication(c *gin.Context) (*app.Context, error) <span class="cov8" title="1">{
        return app.NewContext(c, b.AppConfig), nil
}</span>

func (b BaseHTTPHandler) GuestRunAction(handler HandlerFnInterface) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()
                ctx, err := b.GuestAuthentication(c)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorln(fmt.Sprintf("REQUEST ID: %s , message: Unauthorized", ctx.APIReqID))
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "status":  http.StatusUnauthorized,
                                "message": "Unauthorized",
                                "data":    err.Error(),
                        })
                        return
                }</span>

                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                        if err0 := recover(); err0 != nil </span><span class="cov0" title="0">{
                                logrus.Errorln(err0)
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "status":  http.StatusInternalServerError,
                                        "message": "Request is halted unexpectedly, please contact the administrator.",
                                        "data":    nil,
                                })
                        }</span>
                }()

                <span class="cov8" title="1">resp := handler(ctx)
                httpStatus := resp.Status

                if resp.Data == nil </span><span class="cov0" title="0">{
                        c.Status(httpStatus)
                        return
                }</span>
                <span class="cov8" title="1">end := time.Now().Sub(start)
                logrus.Infoln(fmt.Sprintf("REQUEST ID: %s , LATENCY: %vms", ctx.APIReqID, end.Milliseconds()))
                c.JSON(httpStatus, resp.Data)</span>

        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handler

import (
        "boiler-plate/internal/base/app"
        "boiler-plate/pkg/server"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

func (b BaseHTTPHandler) IsStaging() bool <span class="cov0" title="0">{
        return b.AppConfig.IsStaging()
}</span>

func (b BaseHTTPHandler) HealthCheck(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status":  http.StatusOK,
                "message": "ok",
                "data":    "application running",
        })
}</span>

func (b BaseHTTPHandler) Test(ctx *app.Context) *server.Response <span class="cov0" title="0">{

        logrus.Infoln(ctx.APIReqID)

        return &amp;server.Response{
                Status:  http.StatusOK,
                Message: "Success",
                Data:    nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package domain

import (
        "boiler-plate/internal/users/domain"
        "encoding/json"
        "os"
        "time"
)

const (
        SubmissionsTableName = "submissions"
)

type Submissions struct {
        ID             int             `gorm:"primaryKey;not null;autoIncrement" json:"id"`
        UserId         int             `json:"user_id"`
        User           *domain.Users   `gorm:"foreignKey:UserId;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;" json:"user,omitempty"`
        Answers        json.RawMessage `gorm:"type:json" json:"answers,omitempty"`
        RiskScore      int             `json:"risk_score"`
        RiskCategory   string          `json:"risk_category"`
        RiskDefinition string          `json:"risk_definition"`
        CreatedAt      *time.Time      `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt      *time.Time      `gorm:"autoUpdateTime" json:"updated_at"`
}

type Question struct {
        ID       int      `json:"id"`
        Question string   `json:"question"`
        Options  []Option `json:"options"`
}

type Option struct {
        Answer string `json:"answer"`
        Weight int    `json:"weight"`
}

type RiskProfile struct {
        MinScore   int    `json:"min_score"`
        MaxScore   int    `json:"max_score"`
        Category   string `json:"category"`
        Definition string `json:"definition"`
}

func (model *Submissions) TableName() string <span class="cov8" title="1">{
        return os.Getenv("DB_PREFIX") + SubmissionsTableName
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package domain

const (
        ProfileRiskCategoryConservative = "Conservative"
        ProfileRiskCategoryModerate     = "Moderate"
        ProfileRiskCategoryBalanced     = "Balanced"
        ProfileRiskCategoryGrowth       = "Growth"
        ProfileRiskCategoryAggressive   = "Aggressive"
)

type SubmissionRequest struct {
        UserId  int `validate:"required" json:"user_id"`
        Answers []struct {
                QuestionId int    `json:"question_id"`
                Answer     string `json:"answer"`
        } `json:"answers"`
}

type SubmissionResult struct {
        UserId     int    `json:"user_id"`
        QuestionId int    `json:"question_id"`
        Answer     string `json:"answer"`
}

func (model *Submissions) DeclareRisk(answers []SubmissionResult) <span class="cov8" title="1">{
        score := 0
        for _, answer := range answers </span><span class="cov8" title="1">{
                for _, question := range Questions </span><span class="cov8" title="1">{
                        if question.ID == answer.QuestionId </span><span class="cov8" title="1">{
                                for _, option := range question.Options </span><span class="cov8" title="1">{
                                        if answer.Answer == option.Answer </span><span class="cov0" title="0">{
                                                score += option.Weight
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">model.RiskScore = score
        for _, profile := range RiskMapping </span><span class="cov8" title="1">{
                if score &gt;= profile.MinScore &amp;&amp; score &lt;= profile.MaxScore </span><span class="cov8" title="1">{
                        model.RiskCategory = profile.Category
                        model.RiskDefinition = profile.Definition
                }</span>
        }
}

var Questions = []Question{
        {
                ID:       1,
                Question: "Apakah tujuan investasi Anda?",
                Options: []Option{
                        {Answer: "Pertumbuhan kekayaan untuk jangka panjang", Weight: 5},
                        {Answer: "Pendapatan dan pertumbuhan dalam jangka panjang", Weight: 4},
                        {Answer: "Pendapatan berkala", Weight: 3},
                        {Answer: "Pendapatan dan keamanan dana investasi", Weight: 2},
                        {Answer: "Keamanan dana investasi", Weight: 1},
                },
        },
        {
                ID:       2,
                Question: "Berdasarkan tujuan investasi Anda, dana Anda akan diinvestasikan untuk jangka waktu?",
                Options: []Option{
                        {Answer: "≥ 10 tahun", Weight: 5},
                        {Answer: "7 - 10 tahun", Weight: 4},
                        {Answer: "4 - ≥ 6 tahun", Weight: 3},
                        {Answer: "1 - ≥ 3 tahun", Weight: 2},
                        {Answer: "&lt; 1 tahun", Weight: 1},
                },
        },
        {
                ID:       3,
                Question: "Berapa lama pengalaman Anda berinvestasi dalam produk yang nilainya berfluktuasi?",
                Options: []Option{
                        {Answer: "&gt; 10 tahun", Weight: 5},
                        {Answer: "8 - 10 tahun", Weight: 4},
                        {Answer: "4 - 7 tahun", Weight: 3},
                        {Answer: "&lt; 4 tahun", Weight: 2},
                        {Answer: "0 tahun (tidak memiliki pengalaman)", Weight: 1},
                },
        },
        {
                ID:       4,
                Question: "Jenis investasi apa yang pernah Anda miliki?",
                Options: []Option{
                        {Answer: "Saham, Reksa Dana terbuka, equity linked structure product", Weight: 5},
                        {Answer: "Mata uang asing, currency linked structured product", Weight: 4},
                        {Answer: "Uang tunai, deposito, produk dengan proteksi modal", Weight: 3},
                },
        },
        {
                ID:       5,
                Question: "Berapa persen dari aset Anda yang disimpan dalam produk investasi berfluktuasi?",
                Options: []Option{
                        {Answer: "&gt; 50%", Weight: 5},
                        {Answer: "&gt; 25% - ≥ 50%", Weight: 4},
                        {Answer: "&gt; 10% - ≥ 25%", Weight: 3},
                        {Answer: "&gt; 0% - ≥ 10%", Weight: 2},
                        {Answer: "0%", Weight: 1},
                },
        },
        {
                ID:       6,
                Question: "Tingkat kenaikan dan penurunan nilai investasi yang dapat Anda terima?",
                Options: []Option{
                        {Answer: "&lt; -20% - &gt; +20%", Weight: 5},
                        {Answer: "-20% - +20%", Weight: 4},
                        {Answer: "-15% - +15%", Weight: 3},
                        {Answer: "-10% - +10%", Weight: 2},
                        {Answer: "-5% - +5%", Weight: 1},
                },
        },
        {
                ID:       7,
                Question: "Ketergantungan Anda pada hasil investasi untuk biaya hidup sehari-hari?",
                Options: []Option{
                        {Answer: "Tidak bergantung pada hasil investasi", Weight: 5},
                        {Answer: "Tidak bergantung pada hasil investasi, minimal 5 tahun ke depan", Weight: 4},
                        {Answer: "Sedikit bergantung pada hasil investasi", Weight: 3},
                        {Answer: "Bergantung pada hasil investasi", Weight: 2},
                        {Answer: "Sangat bergantung pada hasil investasi", Weight: 1},
                },
        },
        {
                ID:       8,
                Question: "Persentase pendapatan bulanan yang dapat Anda sisihkan untuk investasi/tabungan?",
                Options: []Option{
                        {Answer: "&gt; 50%", Weight: 5},
                        {Answer: "&gt; 25% - 50%", Weight: 4},
                        {Answer: "&gt; 10% - 25%", Weight: 3},
                        {Answer: "&gt; 0% - 10%", Weight: 2},
                        {Answer: "0%", Weight: 1},
                },
        },
}

var RiskMapping = []RiskProfile{
        {
                MinScore: 0,
                MaxScore: 11,
                Category: ProfileRiskCategoryConservative,
                Definition: "Tujuan utama Anda adalah untuk melindungi modal/dana yang ditempatkan dan Anda tidak memiliki toleransi " +
                        "sama sekali terhadap perubahan harga/nilai dari dana investasinya tersebut. " +
                        "Anda memiliki pengalaman yang sangat terbatas atau tidak memiliki pengalaman sama sekali mengenai produk investasi.",
        },
        {
                MinScore:   12,
                MaxScore:   19,
                Category:   ProfileRiskCategoryModerate,
                Definition: "Anda memiliki toleransi yang rendah dengan perubahan harga/nilai dari dana investasi dan risiko investasi.",
        },
        {
                MinScore: 20,
                MaxScore: 28,
                Category: ProfileRiskCategoryBalanced,
                Definition: "Anda memiliki toleransi yang cukup terhadap produk investasi dan dapat menerima perubahan yang besar dari " +
                        "harga/nilai dari harga yang diinvestasikan.",
        },
        {
                MinScore: 29,
                MaxScore: 35,
                Category: ProfileRiskCategoryGrowth,
                Definition: "Anda memiliki toleransi yang cukup tinggi dan dapat menerima perubahan yang besar dari harga/nilai portfolio" +
                        "pada produk investasi yang diinvestasikan." +
                        "Pada umumnya Anda sudah pernah atau berpengalaman dalam berinvestasi di produk investasi.",
        },
        {
                MinScore: 36,
                MaxScore: 40,
                Category: ProfileRiskCategoryAggressive,
                Definition: "Anda sangat berpengalaman terhadap produk investasi dan memiliki toleransi yang sangat tinggi atas" +
                        "produk-produk investasi. Anda bahkan dapat menerima perubahan signifikan pada modal/nilai investasi." +
                        "Pada umumnya portfolio Anda sebagian besar dialokasikan pada produk investasi.",
        },
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handler

import (
        "boiler-plate/internal/base/app"
        "boiler-plate/internal/base/handler"
        "boiler-plate/internal/submissions/domain"
        "boiler-plate/internal/submissions/service"
        "boiler-plate/pkg/exception"
        "boiler-plate/pkg/httputils"
        "boiler-plate/pkg/server"
        "net/http"
)

type HTTPHandler struct {
        App                *handler.BaseHTTPHandler
        SubmissionsService service.Service
}

func NewHTTPHandler(
        handler *handler.BaseHTTPHandler, SubmissionsService service.Service,
) *HTTPHandler <span class="cov8" title="1">{
        return &amp;HTTPHandler{
                App:                handler,
                SubmissionsService: SubmissionsService,
        }
}</span>

func (h HTTPHandler) Create(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        // Binding JSON
        request := domain.SubmissionRequest{}
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                err := exception.InvalidArgument("error reading request")
                resException := httputils.GenErrorResponseException(err)
                return h.App.AsJsonInterface(ctx, http.StatusBadRequest, resException)
        }</span>

        <span class="cov8" title="1">if err := h.SubmissionsService.Create(ctx, &amp;request); err != nil </span><span class="cov8" title="1">{
                responseException := httputils.GenErrorResponseException(err)
                return h.App.AsJsonInterface(ctx, responseException.StatusCode, responseException)
        }</span>
        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.DataSuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success created",
                Data:       request,
        })</span>
}

func (h HTTPHandler) Detail(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        id := ctx.Param("id")

        // Exec Service
        detailAsset, errException := h.SubmissionsService.Detail(ctx, id)
        if errException != nil </span><span class="cov8" title="1">{
                respException := httputils.GenErrorResponseException(errException)
                return h.App.AsJsonInterface(ctx, respException.StatusCode, respException)
        }</span>
        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.DataSuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success",
                Data:       detailAsset,
        })</span>
}

func (h HTTPHandler) Delete(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        id := ctx.Param("id")

        // Exec Service
        errException := h.SubmissionsService.Delete(ctx, id)
        if errException != nil </span><span class="cov8" title="1">{
                respException := httputils.GenErrorResponseException(errException)
                return h.App.AsJsonInterface(ctx, respException.StatusCode, respException)
        }</span>
        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.SuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success delete id: " + id,
        })</span>
}

func (h HTTPHandler) Find(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        limitParam := ctx.DefaultQuery("pageSize", "0")
        pageParam := ctx.DefaultQuery("page", "0")
        result, err := h.SubmissionsService.Find(ctx, limitParam, pageParam)
        if err != nil </span><span class="cov8" title="1">{
                responseException := httputils.GenErrorResponseException(err)
                return h.App.AsJsonInterface(ctx, responseException.StatusCode, responseException)
        }</span>

        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.DataSuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success",
                Data:       result,
        })</span>
}

func (h HTTPHandler) FindByUser(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        limitParam := ctx.DefaultQuery("pageSize", "0")
        pageParam := ctx.DefaultQuery("page", "0")
        id := ctx.Param("id")
        result, err := h.SubmissionsService.FindByUser(ctx, limitParam, pageParam, id)
        if err != nil </span><span class="cov8" title="1">{
                responseException := httputils.GenErrorResponseException(err)
                return h.App.AsJsonInterface(ctx, responseException.StatusCode, responseException)
        }</span>

        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.DataSuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success",
                Data:       result,
        })</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
        domain "boiler-plate/internal/submissions/domain"
        exception "boiler-plate/pkg/exception"
        context "context"

        mock "github.com/stretchr/testify/mock"

        service "boiler-plate/internal/submissions/service"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
        mock.Mock
}

// Create provides a mock function with given fields: ctx, req
func (_m *Service) Create(ctx context.Context, req *domain.SubmissionRequest) *exception.Exception <span class="cov8" title="1">{
        ret := _m.Called(ctx, req)

        var r0 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, *domain.SubmissionRequest) *exception.Exception); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, req)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// Delete provides a mock function with given fields: ctx, id
func (_m *Service) Delete(ctx context.Context, id string) *exception.Exception <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        var r0 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string) *exception.Exception); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// Detail provides a mock function with given fields: ctx, id
func (_m *Service) Detail(ctx context.Context, id string) (*domain.Submissions, *exception.Exception) <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        var r0 *domain.Submissions
        var r1 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.Submissions, *exception.Exception)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) *domain.Submissions); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.Submissions)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) *exception.Exception); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0, r1</span>
}

// Find provides a mock function with given fields: ctx, limit, page
func (_m *Service) Find(ctx context.Context, limit string, page string) (*service.FindResponse, *exception.Exception) <span class="cov8" title="1">{
        ret := _m.Called(ctx, limit, page)

        var r0 *service.FindResponse
        var r1 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*service.FindResponse, *exception.Exception)); ok </span><span class="cov0" title="0">{
                return rf(ctx, limit, page)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) *service.FindResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*service.FindResponse)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) *exception.Exception); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0, r1</span>
}

// FindByUser provides a mock function with given fields: ctx, limit, page, userid
func (_m *Service) FindByUser(ctx context.Context, limit string, page string, userid string) (*service.FindByUserResponse, *exception.Exception) <span class="cov8" title="1">{
        ret := _m.Called(ctx, limit, page, userid)

        var r0 *service.FindByUserResponse
        var r1 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*service.FindByUserResponse, *exception.Exception)); ok </span><span class="cov0" title="0">{
                return rf(ctx, limit, page, userid)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *service.FindByUserResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, limit, page, userid)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*service.FindByUserResponse)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string, string) *exception.Exception); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, limit, page, userid)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0, r1</span>
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
        mock.TestingT
        Cleanup(func())
}) *Service <span class="cov0" title="0">{
        mock := &amp;Service{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
        db "boiler-plate/pkg/db"
        context "context"

        domain "boiler-plate/internal/submissions/domain"

        gorm "gorm.io/gorm"

        mock "github.com/stretchr/testify/mock"
)

// SubmissionsRepository is an autogenerated mock type for the SubmissionsRepository type
type SubmissionsRepository struct {
        mock.Mock
}

// Create provides a mock function with given fields: ctx, tx, model
func (_m *SubmissionsRepository) Create(ctx context.Context, tx *gorm.DB, model *domain.Submissions) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, model)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, *domain.Submissions) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, model)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Delete provides a mock function with given fields: ctx, tx, key
func (_m *SubmissionsRepository) Delete(ctx context.Context, tx *gorm.DB, key int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, key)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, key)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Detail provides a mock function with given fields: ctx, tx, id
func (_m *SubmissionsRepository) Detail(ctx context.Context, tx *gorm.DB, id int) (*domain.Submissions, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, id)

        var r0 *domain.Submissions
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int) (*domain.Submissions, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, id)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int) *domain.Submissions); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.Submissions)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, id)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// DetailByUser provides a mock function with given fields: ctx, tx, id
func (_m *SubmissionsRepository) DetailByUser(ctx context.Context, tx *gorm.DB, id int) (*domain.Submissions, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, id)

        var r0 *domain.Submissions
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int) (*domain.Submissions, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, id)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int) *domain.Submissions); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.Submissions)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, id)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Find provides a mock function with given fields: ctx, tx, limit, page
func (_m *SubmissionsRepository) Find(ctx context.Context, tx *gorm.DB, limit int, page int) (*[]domain.Submissions, *db.Paginate, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, limit, page)

        var r0 *[]domain.Submissions
        var r1 *db.Paginate
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int, int) (*[]domain.Submissions, *db.Paginate, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, limit, page)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int, int) *[]domain.Submissions); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*[]domain.Submissions)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, int, int) *db.Paginate); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).(*db.Paginate)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(2).(func(context.Context, *gorm.DB, int, int) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, tx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov8" title="1">return r0, r1, r2</span>
}

// FindByUser provides a mock function with given fields: ctx, tx, limit, page, userid
func (_m *SubmissionsRepository) FindByUser(ctx context.Context, tx *gorm.DB, limit int, page int, userid int) (*[]domain.Submissions, *db.Paginate, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, limit, page, userid)

        var r0 *[]domain.Submissions
        var r1 *db.Paginate
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int, int, int) (*[]domain.Submissions, *db.Paginate, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, limit, page, userid)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int, int, int) *[]domain.Submissions); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, limit, page, userid)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*[]domain.Submissions)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, int, int, int) *db.Paginate); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, limit, page, userid)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).(*db.Paginate)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(2).(func(context.Context, *gorm.DB, int, int, int) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, tx, limit, page, userid)
        }</span> else<span class="cov8" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov8" title="1">return r0, r1, r2</span>
}

// Update provides a mock function with given fields: ctx, tx, id, model
func (_m *SubmissionsRepository) Update(ctx context.Context, tx *gorm.DB, id int, model *domain.Submissions) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, tx, id, model)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int, *domain.Submissions) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, id, model)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewSubmissionsRepository creates a new instance of SubmissionsRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubmissionsRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *SubmissionsRepository <span class="cov0" title="0">{
        mock := &amp;SubmissionsRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "boiler-plate/internal/submissions/domain"
        baseModel "boiler-plate/pkg/db"
        "boiler-plate/pkg/errs"
        "context"
        "errors"
        "gorm.io/gorm"
)

type Repo struct {
        db   *gorm.DB
        base *baseModel.SQLClientRepository
}

func NewRepository(db *gorm.DB, base *baseModel.SQLClientRepository) SubmissionsRepository <span class="cov8" title="1">{
        return &amp;Repo{db: db, base: base}
}</span>

func (r Repo) Create(ctx context.Context, tx *gorm.DB, model *domain.Submissions) error <span class="cov8" title="1">{
        query := tx.WithContext(ctx)
        if err := query.Model(&amp;domain.Submissions{}).Create(&amp;model).
                Error; err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r Repo) Delete(ctx context.Context, tx *gorm.DB, key int) error <span class="cov8" title="1">{
        query := tx.WithContext(ctx)

        if err := query.
                Delete(&amp;domain.Submissions{ID: key}).Error; err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r Repo) Update(ctx context.Context, tx *gorm.DB, id int, model *domain.Submissions) error <span class="cov8" title="1">{
        query := tx.WithContext(ctx)
        if err := query.
                Model(&amp;domain.Submissions{ID: id}).
                Updates(model).
                Error; err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r Repo) Find(ctx context.Context, tx *gorm.DB, limit, page int) (
        *[]domain.Submissions, *baseModel.Paginate, error,
) <span class="cov8" title="1">{
        var (
                models *[]domain.Submissions
        )
        tx = tx.WithContext(ctx).
                Model(&amp;domain.Submissions{})
        pagination := baseModel.NewPaginate(limit, page)
        if err := tx.
                Scopes(pagination.PaginatedResult(&amp;models, tx)).
                Find(&amp;models).
                Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, pagination, nil
                }</span>
                <span class="cov8" title="1">return nil, nil, errs.Wrap(err)</span>
        }
        <span class="cov8" title="1">return models, pagination, nil</span>
}

func (r Repo) FindByUser(ctx context.Context, tx *gorm.DB, limit, page, userid int) (
        *[]domain.Submissions, *baseModel.Paginate, error,
) <span class="cov8" title="1">{
        var (
                models *[]domain.Submissions
        )
        pagination := baseModel.NewPaginate(limit, page)
        tx = tx.WithContext(ctx).
                Model(&amp;domain.Submissions{}).
                Where("user_id = ?", userid)
        if err := tx.
                Scopes(pagination.PaginatedResult(&amp;models, tx)).
                Find(&amp;models).
                Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, pagination, nil
                }</span>
                <span class="cov8" title="1">return nil, nil, errs.Wrap(err)</span>
        }
        <span class="cov8" title="1">return models, pagination, nil</span>
}

func (r Repo) Detail(ctx context.Context, tx *gorm.DB, id int) (*domain.Submissions, error) <span class="cov8" title="1">{
        var (
                models *domain.Submissions
        )

        if err := tx.WithContext(ctx).
                Model(&amp;domain.Submissions{}).
                Preload("User").
                First(&amp;models, id).
                Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return models, nil</span>
}

func (r Repo) DetailByUser(ctx context.Context, tx *gorm.DB, id int) (*domain.Submissions, error) <span class="cov8" title="1">{
        var (
                models *domain.Submissions
        )

        if err := tx.WithContext(ctx).
                Model(&amp;domain.Submissions{}).
                Order("created_at DESC").
                First(&amp;models, "user_id = ?", id).
                Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return models, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package service

import (
        "boiler-plate/app/appconf"
        "boiler-plate/internal/submissions/domain"
        "boiler-plate/internal/submissions/repository"
        "boiler-plate/pkg/exception"
        "context"
        "encoding/json"
        "github.com/go-playground/validator/v10"
        "gorm.io/gorm"
        "strconv"
)

// NewService creates new user service
func NewService(
        config *appconf.Config, repo repository.SubmissionsRepository, db *gorm.DB, validate *validator.Validate,
) Service <span class="cov8" title="1">{
        return &amp;service{config: config, SubmissionsRepo: repo, validate: validate, DB: db}
}</span>

type service struct {
        DB              *gorm.DB
        config          *appconf.Config
        SubmissionsRepo repository.SubmissionsRepository
        validate        *validator.Validate
}

func (s service) Create(
        ctx context.Context, req *domain.SubmissionRequest,
) *exception.Exception <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        if err := s.validate.Struct(req); err != nil </span><span class="cov8" title="1">{
                return exception.InvalidArgument(err)
        }</span>

        <span class="cov8" title="1">var answers []domain.SubmissionResult
        for _, answer := range req.Answers </span><span class="cov8" title="1">{
                answers = append(answers, domain.SubmissionResult{
                        UserId:     req.UserId,
                        QuestionId: answer.QuestionId,
                        Answer:     answer.Answer,
                })
        }</span>
        <span class="cov8" title="1">jsonData, err := json.Marshal(answers)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Internal("error marshalling old value", err)
        }</span>
        <span class="cov8" title="1">body := &amp;domain.Submissions{
                UserId:  req.UserId,
                Answers: jsonData,
        }
        body.DeclareRisk(answers)
        if err := s.SubmissionsRepo.Create(ctx, tx, body); err != nil </span><span class="cov8" title="1">{
                return exception.Internal("error inserting submissions", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s service) Delete(ctx context.Context, id string) *exception.Exception <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                return exception.PermissionDenied("Input of id must be integer")
        }</span>
        <span class="cov8" title="1">err = s.SubmissionsRepo.Delete(ctx, tx, idInt)
        if err != nil </span><span class="cov8" title="1">{
                return exception.Internal("error deleting submissions", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s service) Find(ctx context.Context, limit, page string) (*FindResponse, *exception.Exception) <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        var limitInt, pageInt int
        limitInt, err := strconv.Atoi(limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of limit must be integer")
        }</span>
        <span class="cov8" title="1">pageInt, err = strconv.Atoi(page)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of page must be integer")
        }</span>
        <span class="cov8" title="1">result, pagination, err := s.SubmissionsRepo.Find(ctx, tx, limitInt, pageInt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("error getting submissions", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">finalResponse := &amp;FindResponse{
                Pagination: *pagination,
                Data:       *result,
        }
        return finalResponse, nil</span>
}

func (s service) FindByUser(ctx context.Context, limit, page, userid string) (
        *FindByUserResponse, *exception.Exception,
) <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        idInt, err := strconv.Atoi(userid)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of id must be integer")
        }</span>
        <span class="cov8" title="1">var limitInt, pageInt int
        limitInt, err = strconv.Atoi(limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of limit must be integer")
        }</span>
        <span class="cov8" title="1">pageInt, err = strconv.Atoi(page)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of page must be integer")
        }</span>

        <span class="cov8" title="1">result, pagination, err := s.SubmissionsRepo.FindByUser(ctx, tx, limitInt, pageInt, idInt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("error getting submissions", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">finalResponse := &amp;FindByUserResponse{
                UserId:     idInt,
                Pagination: *pagination,
                Data:       *result,
        }
        return finalResponse, nil</span>
}

func (s service) Detail(ctx context.Context, id string) (*domain.Submissions, *exception.Exception) <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of id must be integer")
        }</span>
        <span class="cov8" title="1">result, err := s.SubmissionsRepo.Detail(ctx, tx, idInt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("error getting detail submissions", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package domain

import (
        "os"
        "time"
)

const (
        UsersTableName = "users"
)

type Users struct {
        ID        int        `gorm:"primaryKey;not null;autoIncrement" json:"id"`
        Email     string     `validate:"required,gt=2" json:"email,omitempty"`
        Password  string     `json:"password,omitempty"`
        CreatedAt *time.Time `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt *time.Time `gorm:"autoUpdateTime" json:"updated_at"`
}

type UserResponse struct {
        ID             int        `gorm:"primaryKey;not null;autoIncrement" json:"id"`
        Email          string     `validate:"required,gt=2" json:"email,omitempty"`
        Password       string     `json:"password,omitempty"`
        RiskScore      int        `json:"risk_score"`
        RiskCategory   string     `json:"risk_category"`
        RiskDefinition string     `json:"risk_definition"`
        CreatedAt      *time.Time `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt      *time.Time `gorm:"autoUpdateTime" json:"updated_at"`
}

func (model *UserResponse) DeclareRiskProfile(riskscore int, riskcategory, riskdefinition string) <span class="cov8" title="1">{
        model.RiskScore = riskscore
        model.RiskCategory = riskcategory
        model.RiskDefinition = riskdefinition
}</span>

func (model *Users) TableName() string <span class="cov8" title="1">{
        return os.Getenv("DB_PREFIX") + UsersTableName
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package handler

import (
        "boiler-plate/internal/base/app"
        "boiler-plate/internal/base/handler"
        "boiler-plate/internal/users/domain"
        "boiler-plate/internal/users/service"
        "boiler-plate/pkg/exception"
        "boiler-plate/pkg/httputils"
        "boiler-plate/pkg/server"
        "net/http"
)

type HTTPHandler struct {
        App          *handler.BaseHTTPHandler
        UsersService service.Service
}

func NewHTTPHandler(
        handler *handler.BaseHTTPHandler, UsersService service.Service,
) *HTTPHandler <span class="cov8" title="1">{
        return &amp;HTTPHandler{
                App:          handler,
                UsersService: UsersService,
        }
}</span>

func (h HTTPHandler) Create(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        // Binding JSON
        request := domain.Users{}
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                err := exception.InvalidArgument("error reading request")
                resException := httputils.GenErrorResponseException(err)
                return h.App.AsJsonInterface(ctx, http.StatusBadRequest, resException)
        }</span>

        <span class="cov8" title="1">if err := h.UsersService.Create(ctx, &amp;request); err != nil </span><span class="cov8" title="1">{
                responseException := httputils.GenErrorResponseException(err)
                return h.App.AsJsonInterface(ctx, responseException.StatusCode, responseException)
        }</span>
        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.DataSuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success created",
                Data:       request,
        })</span>
}

func (h HTTPHandler) Update(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        id := ctx.Param("id")
        // Binding JSON
        request := domain.Users{}
        if err := ctx.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                err := exception.InvalidArgument("error reading request")
                resException := httputils.GenErrorResponseException(err)
                return h.App.AsJsonInterface(ctx, http.StatusBadRequest, resException)
        }</span>

        // Exec Service
        <span class="cov8" title="1">errException := h.UsersService.Update(ctx, id, &amp;request)
        if errException != nil </span><span class="cov8" title="1">{
                responseException := httputils.GenErrorResponseException(errException)
                return h.App.AsJsonInterface(ctx, responseException.StatusCode, responseException)
        }</span>

        // return
        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.DataSuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success update",
                Data:       request,
        })</span>
}

func (h HTTPHandler) Detail(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        id := ctx.Param("id")

        // Exec Service
        detailAsset, errException := h.UsersService.Detail(ctx, id)
        if errException != nil </span><span class="cov8" title="1">{
                respException := httputils.GenErrorResponseException(errException)
                return h.App.AsJsonInterface(ctx, respException.StatusCode, respException)
        }</span>
        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.DataSuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success",
                Data:       detailAsset,
        })</span>
}

func (h HTTPHandler) Delete(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        id := ctx.Param("id")

        // Exec Service
        errException := h.UsersService.Delete(ctx, id)
        if errException != nil </span><span class="cov8" title="1">{
                respException := httputils.GenErrorResponseException(errException)
                return h.App.AsJsonInterface(ctx, respException.StatusCode, respException)
        }</span>
        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.SuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success delete id: " + id,
        })</span>
}

func (h HTTPHandler) Find(ctx *app.Context) *server.ResponseInterface <span class="cov8" title="1">{
        limitParam := ctx.DefaultQuery("pageSize", "0")
        pageParam := ctx.DefaultQuery("page", "0")
        result, err := h.UsersService.Find(ctx, limitParam, pageParam)
        if err != nil </span><span class="cov8" title="1">{
                responseException := httputils.GenErrorResponseException(err)
                return h.App.AsJsonInterface(ctx, responseException.StatusCode, responseException)
        }</span>

        <span class="cov8" title="1">return h.App.AsJsonInterface(ctx, http.StatusOK, httputils.DataSuccessResponse{
                StatusCode: http.StatusOK,
                Message:    "success",
                Data:       result,
        })</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
        domain "boiler-plate/internal/users/domain"
        exception "boiler-plate/pkg/exception"
        context "context"

        mock "github.com/stretchr/testify/mock"

        service "boiler-plate/internal/users/service"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
        mock.Mock
}

// Auth provides a mock function with given fields: ctx, email, password
func (_m *Service) Auth(ctx context.Context, email string, password string) (*domain.Users, *exception.Exception) <span class="cov0" title="0">{
        ret := _m.Called(ctx, email, password)

        var r0 *domain.Users
        var r1 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*domain.Users, *exception.Exception)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) *domain.Users); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, password)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.Users)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) *exception.Exception); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, password)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(1) != nil </span><span class="cov0" title="0">{
                        r1 = ret.Get(1).(*exception.Exception)
                }</span>
        }

        <span class="cov0" title="0">return r0, r1</span>
}

// Create provides a mock function with given fields: ctx, req
func (_m *Service) Create(ctx context.Context, req *domain.Users) *exception.Exception <span class="cov8" title="1">{
        ret := _m.Called(ctx, req)

        var r0 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, *domain.Users) *exception.Exception); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, req)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// Delete provides a mock function with given fields: ctx, id
func (_m *Service) Delete(ctx context.Context, id string) *exception.Exception <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        var r0 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string) *exception.Exception); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// Detail provides a mock function with given fields: ctx, id
func (_m *Service) Detail(ctx context.Context, id string) (*domain.UserResponse, *exception.Exception) <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        var r0 *domain.UserResponse
        var r1 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.UserResponse, *exception.Exception)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) *domain.UserResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.UserResponse)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) *exception.Exception); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0, r1</span>
}

// Find provides a mock function with given fields: ctx, limit, page
func (_m *Service) Find(ctx context.Context, limit string, page string) (*service.FindResponse, *exception.Exception) <span class="cov8" title="1">{
        ret := _m.Called(ctx, limit, page)

        var r0 *service.FindResponse
        var r1 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*service.FindResponse, *exception.Exception)); ok </span><span class="cov0" title="0">{
                return rf(ctx, limit, page)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) *service.FindResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*service.FindResponse)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) *exception.Exception); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0, r1</span>
}

// Update provides a mock function with given fields: ctx, id, users
func (_m *Service) Update(ctx context.Context, id string, users *domain.Users) *exception.Exception <span class="cov8" title="1">{
        ret := _m.Called(ctx, id, users)

        var r0 *exception.Exception
        if rf, ok := ret.Get(0).(func(context.Context, string, *domain.Users) *exception.Exception); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id, users)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*exception.Exception)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
        mock.TestingT
        Cleanup(func())
}) *Service <span class="cov0" title="0">{
        mock := &amp;Service{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
        db "boiler-plate/pkg/db"
        context "context"

        domain "boiler-plate/internal/users/domain"

        gorm "gorm.io/gorm"

        mock "github.com/stretchr/testify/mock"
)

// UsersRepository is an autogenerated mock type for the UsersRepository type
type UsersRepository struct {
        mock.Mock
}

// Auth provides a mock function with given fields: ctx, tx, users, password
func (_m *UsersRepository) Auth(ctx context.Context, tx *gorm.DB, users string, password string) (*domain.Users, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, users, password)

        var r0 *domain.Users
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, string, string) (*domain.Users, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, users, password)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, string, string) *domain.Users); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, users, password)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.Users)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, users, password)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Create provides a mock function with given fields: ctx, tx, model
func (_m *UsersRepository) Create(ctx context.Context, tx *gorm.DB, model *domain.Users) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, model)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, *domain.Users) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, model)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Delete provides a mock function with given fields: ctx, tx, key
func (_m *UsersRepository) Delete(ctx context.Context, tx *gorm.DB, key int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, key)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, key)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Detail provides a mock function with given fields: ctx, tx, id
func (_m *UsersRepository) Detail(ctx context.Context, tx *gorm.DB, id int) (*domain.UserResponse, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, id)

        var r0 *domain.UserResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int) (*domain.UserResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, id)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int) *domain.UserResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, id)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*domain.UserResponse)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, id)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Find provides a mock function with given fields: ctx, tx, limit, page
func (_m *UsersRepository) Find(ctx context.Context, tx *gorm.DB, limit int, page int) (*[]domain.UserResponse, *db.Paginate, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, limit, page)

        var r0 *[]domain.UserResponse
        var r1 *db.Paginate
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int, int) (*[]domain.UserResponse, *db.Paginate, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tx, limit, page)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int, int) *[]domain.UserResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*[]domain.UserResponse)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *gorm.DB, int, int) *db.Paginate); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).(*db.Paginate)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(2).(func(context.Context, *gorm.DB, int, int) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, tx, limit, page)
        }</span> else<span class="cov8" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov8" title="1">return r0, r1, r2</span>
}

// Update provides a mock function with given fields: ctx, tx, id, model
func (_m *UsersRepository) Update(ctx context.Context, tx *gorm.DB, id int, model *domain.Users) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, tx, id, model)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *gorm.DB, int, *domain.Users) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tx, id, model)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewUsersRepository creates a new instance of UsersRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUsersRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *UsersRepository <span class="cov0" title="0">{
        mock := &amp;UsersRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "boiler-plate/internal/users/domain"
        baseModel "boiler-plate/pkg/db"
        "boiler-plate/pkg/errs"
        "context"
        "errors"
        "gorm.io/gorm"
)

type Repo struct {
        db   *gorm.DB
        base *baseModel.SQLClientRepository
}

func NewRepository(db *gorm.DB, base *baseModel.SQLClientRepository) UsersRepository <span class="cov8" title="1">{
        return &amp;Repo{db: db, base: base}
}</span>

func (r Repo) Create(ctx context.Context, tx *gorm.DB, model *domain.Users) error <span class="cov8" title="1">{
        query := tx.WithContext(ctx)
        if err := query.Model(&amp;domain.Users{}).Create(&amp;model).
                Error; err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r Repo) Delete(ctx context.Context, tx *gorm.DB, key int) error <span class="cov8" title="1">{
        query := tx.WithContext(ctx)

        if err := query.
                Delete(&amp;domain.Users{ID: key}).Error; err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r Repo) Update(ctx context.Context, tx *gorm.DB, id int, model *domain.Users) error <span class="cov8" title="1">{
        query := tx.WithContext(ctx)
        if err := query.
                Model(&amp;domain.Users{ID: id}).
                Updates(model).
                Error; err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r Repo) Find(ctx context.Context, tx *gorm.DB, limit, page int) (
        *[]domain.UserResponse, *baseModel.Paginate, error,
) <span class="cov8" title="1">{
        var (
                models *[]domain.UserResponse
        )
        tx = tx.WithContext(ctx).
                Select("id", "email", "password", "created_at", "updated_at").
                Model(&amp;domain.Users{})
        pagination := baseModel.NewPaginate(limit, page)
        if err := tx.
                Scopes(pagination.PaginatedResult(&amp;domain.Users{}, tx)).
                Find(&amp;models).
                Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, pagination, nil
                }</span>
                <span class="cov8" title="1">return nil, nil, errs.Wrap(err)</span>
        }
        <span class="cov8" title="1">return models, pagination, nil</span>
}

func (r Repo) Detail(ctx context.Context, tx *gorm.DB, id int) (*domain.UserResponse, error) <span class="cov8" title="1">{
        var (
                models *domain.UserResponse
        )

        if err := tx.WithContext(ctx).
                Select("id", "email", "password", "created_at", "updated_at").
                Model(&amp;domain.Users{}).
                First(&amp;models, id).
                Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return models, nil</span>
}

func (r Repo) Auth(ctx context.Context, tx *gorm.DB, users, password string) (*domain.Users, error) <span class="cov8" title="1">{
        var (
                models *domain.Users
        )

        if err := tx.WithContext(ctx).
                Model(&amp;domain.Users{}).
                Where("email = ?", users).Where("password = ?", password).
                First(&amp;models).
                Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return models, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package service

import (
        "boiler-plate/app/appconf"
        subRepo "boiler-plate/internal/submissions/repository"
        "boiler-plate/internal/users/domain"
        "boiler-plate/internal/users/repository"
        "boiler-plate/pkg/exception"
        "context"
        "github.com/go-playground/validator/v10"
        "gorm.io/gorm"
        "strconv"
)

// NewService creates new user service
func NewService(
        config *appconf.Config, repo repository.UsersRepository, submissionrepo subRepo.SubmissionsRepository, db *gorm.DB,
        validate *validator.Validate,
) Service <span class="cov8" title="1">{
        return &amp;service{config: config, UsersRepo: repo, SubmissionsRepo: submissionrepo, validate: validate, DB: db}
}</span>

type service struct {
        DB              *gorm.DB
        config          *appconf.Config
        UsersRepo       repository.UsersRepository
        SubmissionsRepo subRepo.SubmissionsRepository
        validate        *validator.Validate
}

func (s service) Create(
        ctx context.Context, req *domain.Users,
) *exception.Exception <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        if err := s.validate.Struct(req); err != nil </span><span class="cov8" title="1">{
                return exception.InvalidArgument(err)
        }</span>
        <span class="cov8" title="1">err := s.UsersRepo.Create(ctx, tx, req)
        if err != nil </span><span class="cov8" title="1">{
                return exception.Internal("error inserting users", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s service) Update(
        ctx context.Context, id string, users *domain.Users,
) *exception.Exception <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        if err := s.validate.Struct(users); err != nil </span><span class="cov8" title="1">{
                return exception.InvalidArgument(err)
        }</span>
        <span class="cov8" title="1">idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                return exception.PermissionDenied("Input of id must be integer")
        }</span>
        <span class="cov8" title="1">err = s.UsersRepo.Update(ctx, tx, idInt, users)
        if err != nil </span><span class="cov8" title="1">{
                return exception.Internal("error updating users", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s service) Delete(ctx context.Context, id string) *exception.Exception <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                return exception.PermissionDenied("Input of id must be integer")
        }</span>
        <span class="cov8" title="1">err = s.UsersRepo.Delete(ctx, tx, idInt)
        if err != nil </span><span class="cov8" title="1">{
                return exception.Internal("error deleting users", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s service) Find(ctx context.Context, limit string, page string) (*FindResponse, *exception.Exception) <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        var limitInt, pageInt int

        limitInt, err := strconv.Atoi(limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of limit must be integer")
        }</span>
        <span class="cov8" title="1">pageInt, err = strconv.Atoi(page)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of page must be integer")
        }</span>
        <span class="cov8" title="1">result, pagination, err := s.UsersRepo.Find(ctx, tx, limitInt, pageInt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("error geting users", err)
        }</span>
        <span class="cov8" title="1">if len(*result) &gt; 0 </span><span class="cov8" title="1">{
                for i, response := range *result </span><span class="cov8" title="1">{
                        latestSubmissions, err := s.SubmissionsRepo.DetailByUser(ctx, tx, response.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, exception.Internal("error getting detail submissions", err)
                        }</span>
                        <span class="cov8" title="1">if latestSubmissions != nil </span><span class="cov8" title="1">{
                                (*result)[i].DeclareRiskProfile(latestSubmissions.RiskScore, latestSubmissions.RiskCategory, latestSubmissions.RiskDefinition)
                        }</span>
                }
        }
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">finalResponse := &amp;FindResponse{
                Pagination: *pagination,
                Data:       *result,
        }
        return finalResponse, nil</span>
}

func (s service) Detail(ctx context.Context, id string) (*domain.UserResponse, *exception.Exception) <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.PermissionDenied("Input of id must be integer")
        }</span>
        <span class="cov8" title="1">result, err := s.UsersRepo.Detail(ctx, tx, idInt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("error getting detail users", err)
        }</span>
        <span class="cov8" title="1">if result == nil </span><span class="cov8" title="1">{
                return nil, exception.NotFound("detail not found")
        }</span>
        <span class="cov8" title="1">latestSubmissions, err := s.SubmissionsRepo.DetailByUser(ctx, tx, result.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("error getting detail submissions", err)
        }</span>
        <span class="cov8" title="1">if latestSubmissions != nil </span><span class="cov8" title="1">{
                result.DeclareRiskProfile(latestSubmissions.RiskScore, latestSubmissions.RiskCategory, latestSubmissions.RiskDefinition)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func (s service) Auth(ctx context.Context, email, password string) (*domain.Users, *exception.Exception) <span class="cov8" title="1">{
        tx := s.DB.Begin()
        defer tx.Rollback()
        result, err := s.UsersRepo.Auth(ctx, tx, email, password)
        if err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("error finding users", err)
        }</span>
        <span class="cov8" title="1">if err := tx.Commit().Error; err != nil </span><span class="cov8" title="1">{
                return nil, exception.Internal("commit transaction", err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package main

import (
        "boiler-plate/cmd"
        "github.com/sirupsen/logrus"
        "os"
)

func main() <span class="cov0" title="0">{

        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                logrus.Errorln("error on command execution", err.Error())
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package kafkaservice

import (
        "crypto/tls"
        "fmt"
        "log/slog"
        "os"

        "github.com/segmentio/kafka-go"
        "github.com/segmentio/kafka-go/sasl"
        "github.com/segmentio/kafka-go/sasl/plain"
        "github.com/segmentio/kafka-go/sasl/scram"
)

type Config struct {
        SecurityProtocol string
        Brokers          []string
        Username         string
        Password         string
}

type KafkaService struct {
        brokers     []string
        mechanism   sasl.Mechanism
        tls         *tls.Config
        errorLogger kafka.Logger
        logger      kafka.Logger
}

func New(config *Config) *KafkaService <span class="cov0" title="0">{
        var mechanism sasl.Mechanism
        var tlsConfig *tls.Config

        if config.SecurityProtocol == "SCRAM_SHA_256" </span><span class="cov0" title="0">{
                var err error
                mechanism, err = scram.Mechanism(scram.SHA256, config.Username, config.Password)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("can't setup kafka server", "error", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> if config.SecurityProtocol == "SCRAM_SHA_512" </span><span class="cov0" title="0">{
                var err error
                mechanism, err = scram.Mechanism(scram.SHA512, config.Username, config.Password)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("can't setup kafka server", "error", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> if config.SecurityProtocol == "SASL_SSL" </span><span class="cov0" title="0">{
                mechanism = plain.Mechanism{
                        Username: config.Username,
                        Password: config.Password,
                }
                tlsConfig = &amp;tls.Config{}
        }</span> else<span class="cov0" title="0"> if config.SecurityProtocol == "SASL_PLAIN" </span><span class="cov0" title="0">{
                mechanism = plain.Mechanism{
                        Username: config.Username,
                        Password: config.Password,
                }
                tlsConfig = nil
        }</span> else<span class="cov0" title="0"> if config.SecurityProtocol == "PLAIN" </span><span class="cov0" title="0">{
                mechanism = nil
                tlsConfig = nil
        }</span> else<span class="cov0" title="0"> {
                slog.Error("can't setup kafka server", "error", "invalid security protocol")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">slog.Debug(fmt.Sprintf("kafka security protocol %s", config.SecurityProtocol))
        slog.Debug("kafka module initialized")

        return &amp;KafkaService{
                brokers:   config.Brokers,
                mechanism: mechanism,
                tls:       tlsConfig,
                errorLogger: kafka.LoggerFunc(func(message string, args ...interface{}) </span><span class="cov0" title="0">{
                        slog.Error(fmt.Sprintf(message, args...))
                }</span>),
                // logger: kafka.LoggerFunc(func(message string, args ...interface{}) {
                //         slog.Debug(fmt.Sprintf(message, args...))
                // }),
        }
}

func (k *KafkaService) NewReader(topic string, groupID string) *kafka.Reader <span class="cov0" title="0">{
        return kafka.NewReader(kafka.ReaderConfig{
                Brokers: k.brokers,
                Topic:   topic,
                GroupID: groupID,
                Dialer: &amp;kafka.Dialer{
                        SASLMechanism: k.mechanism,
                        TLS:           k.tls,
                },
                ErrorLogger: k.errorLogger,
                Logger:      k.logger,
        })
}</span>

func (k *KafkaService) NewWriter(topic string) *kafka.Writer <span class="cov0" title="0">{
        return &amp;kafka.Writer{
                Addr:     kafka.TCP(k.brokers...),
                Topic:    topic,
                Balancer: &amp;kafka.LeastBytes{},
                Transport: &amp;kafka.Transport{
                        SASL: k.mechanism,
                        TLS:  k.tls,
                },
                ErrorLogger: k.errorLogger,
                Logger:      k.logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package db

import (
        appConfiguration "boiler-plate/app/appconf"
        "database/sql"
        "fmt"
        "github.com/pkg/errors"
        "github.com/sirupsen/logrus"
        "github.com/uptrace/opentelemetry-go-extra/otelgorm"
        "gorm.io/driver/mysql"
        "gorm.io/driver/postgres"
        "gorm.io/driver/sqlserver"
        "gorm.io/gorm"
        "os"
        "strconv"
        "time"
)

type SQLClientRepository struct {
        DB *gorm.DB
        TZ string
}

func NewSQLClientRepository(
        appConfig *appConfiguration.Config, config *gorm.Config,
) (*SQLClientRepository, error) <span class="cov0" title="0">{
        tz := "Asia/Jakarta"

        if config == nil </span><span class="cov0" title="0">{
                config = &amp;gorm.Config{}
        }</span>
        <span class="cov0" title="0">db, _ := gorm.Open(nil, config)
        maxIdleConn, _ := strconv.Atoi(os.Getenv("DB_MAX_IDLE_CONNECTION"))
        lifetimeConn, _ := time.ParseDuration(os.Getenv("DB_MAX_LIFETIME_CONNECTION"))
        var dsn string
        switch appConfig.DatabaseConfig.Dbservice </span>{
        case "postgres", "pgsql":<span class="cov0" title="0">
                dsn = fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%d sslmode=disable TimeZone=%s",
                        appConfig.DatabaseConfig.Dbhost,
                        appConfig.DatabaseConfig.Dbuser,
                        appConfig.DatabaseConfig.Dbpassword,
                        appConfig.DatabaseConfig.Dbdatabase,
                        appConfig.DatabaseConfig.Dbport, tz)
                sqlDB, err := sql.Open("pgx", dsn)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Error(fmt.Sprintf("Cannot connect to PostgresSQL. %v", err))
                        return nil, errors.Wrap(err, "Cannot connect to PostgresSQL")
                }</span>
                <span class="cov0" title="0">sqlDB.SetMaxIdleConns(maxIdleConn)
                sqlDB.SetConnMaxLifetime(lifetimeConn)
                db, err = gorm.Open(postgres.New(postgres.Config{Conn: sqlDB}), config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Error(fmt.Sprintf("Cannot connect to PostgresSQL. %v", err))
                        return nil, errors.Wrap(err, "Cannot connect to PostgresSQL")
                }</span>
        case "mysql":<span class="cov0" title="0">
                dsn = fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true",
                        appConfig.DatabaseConfig.Dbuser,
                        appConfig.DatabaseConfig.Dbpassword,
                        appConfig.DatabaseConfig.Dbhost,
                        appConfig.DatabaseConfig.Dbport,
                        appConfig.DatabaseConfig.Dbdatabase)
                sqlDB, err := sql.Open("mysql", dsn)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Error(fmt.Sprintf("Cannot connect to MySQL. %v", err))
                        return nil, errors.Wrap(err, "Cannot connect to MySQL")
                }</span>
                <span class="cov0" title="0">sqlDB.SetMaxIdleConns(maxIdleConn)
                sqlDB.SetConnMaxLifetime(lifetimeConn)
                db, err = gorm.Open(mysql.New(mysql.Config{Conn: sqlDB}), config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Panic(fmt.Sprintf("Cannot connect to MySQL. %v", err))
                        return nil, errors.Wrap(err, "Cannot connect to MySQL")
                }</span>
                //db.Use(otelgorm.NewPlugin())
        case "sqlserver":<span class="cov0" title="0">
                var err error
                dsn = fmt.Sprintf("sqlserver://%s:%s@%s?database=%s",
                        appConfig.DatabaseConfig.Dbuser,
                        appConfig.DatabaseConfig.Dbpassword,
                        appConfig.DatabaseConfig.Dbhost,
                        appConfig.DatabaseConfig.Dbdatabase)
                db, err = gorm.Open(sqlserver.Open(dsn), config)
                sqlDB, err := db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Errorln("failed to configure connection pool", "error", err.Error())
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">sqlDB.SetMaxIdleConns(maxIdleConn)
                sqlDB.SetConnMaxLifetime(lifetimeConn)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Panic(fmt.Sprintf("Cannot connect to SQL Server. %v", err))
                        return nil, errors.Wrap(err, "Cannot connect to SQL Server")
                }</span>
        default:<span class="cov0" title="0">
                logrus.Errorln("unknown database driver")
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">db.Use(otelgorm.NewPlugin())

        if db == nil </span><span class="cov0" title="0">{
                panic("missing db")</span>
        }

        <span class="cov0" title="0">return &amp;SQLClientRepository{DB: db, TZ: tz}, nil</span>

}
</pre>
		
		<pre class="file" id="file34" style="display: none">package db

import (
        "context"
        "fmt"
        "github.com/pkg/errors"
        "github.com/sirupsen/logrus"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "math"
        "os"
)

type MongoDBClientRepository struct {
        Client *mongo.Client
        DB     *mongo.Database
}

func NewMongoDBRepository(host, uname, pass string, port int) (
        *MongoDBClientRepository, error,
) <span class="cov0" title="0">{
        //var dsn string
        //dsn = fmt.Sprintf(os.Getenv("MONGODB_URL"))
        clientOptions := options.Client().ApplyURI(os.Getenv("MONGODB_URL"))
        client, err := mongo.Connect(context.Background(), clientOptions)
        Users := client.Database(os.Getenv("MONGODB_DB"))
        if err != nil </span><span class="cov0" title="0">{
                logrus.Error(fmt.Sprintf("Cannot connect to MongoDB. %v", err))
                return nil, errors.Wrap(err, "Cannot connect to MongoDB")
        }</span>

        <span class="cov0" title="0">err = client.Ping(context.Background(), nil)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Error(fmt.Sprintf("Cannot send/receive data with MongoDB. %v", err))
                return nil, errors.Wrap(err, "Cannot send/receive data with MongoDB")
        }</span>
        <span class="cov0" title="0">return &amp;MongoDBClientRepository{Client: client, DB: Users}, nil</span>
}

type MongoPaginate struct {
        Limit      int64 `json:"limit,omitempty"`
        Page       int64 `json:"page,omitempty"`
        TotalRows  int64 `json:"total_rows,omitempty"`
        TotalPages int64 `json:"total_pages,omitempty"`
}

func (mp *MongoPaginate) GetPaginatedOpts() *options.FindOptions <span class="cov0" title="0">{
        l := mp.Limit
        skip := mp.Page*mp.Limit - mp.Limit
        fOpt := options.FindOptions{Limit: &amp;l, Skip: &amp;skip}

        return &amp;fOpt
}</span>

func (mp *MongoPaginate) InitiateTotal(count int64) <span class="cov0" title="0">{
        if mp.Limit == 0 </span><span class="cov0" title="0">{
                mp.Limit = count
        }</span>
        <span class="cov0" title="0">if mp.Page == 0 </span><span class="cov0" title="0">{
                mp.Page = 1
        }</span>
        <span class="cov0" title="0">mp.TotalRows = count
        mp.TotalPages = int64(math.Ceil(float64(count) / float64(mp.Limit)))</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package db

import (
        "gorm.io/gorm"
        "math"
)

type Paginate struct {
        Limit      int `json:"limit,omitempty"`
        Page       int `json:"page,omitempty"`
        TotalRows  int `json:"total_rows,omitempty"`
        TotalPages int `json:"total_pages,omitempty"`
}

func NewPaginate(limit, page int) *Paginate <span class="cov8" title="1">{
        return &amp;Paginate{
                Limit: limit, Page: page,
        }
}</span>

func (p *Paginate) PaginatedResult(value interface{}, db *gorm.DB) func(db *gorm.DB) *gorm.DB <span class="cov8" title="1">{
        var totalRows int64
        db.Model(value).Count(&amp;totalRows)
        if p.Limit == 0 </span><span class="cov0" title="0">{
                p.Limit = int(totalRows)
        }</span>
        <span class="cov8" title="1">if p.Page == 0 </span><span class="cov0" title="0">{
                p.Page = 1
        }</span>
        <span class="cov8" title="1">offset := (p.Page - 1) * p.Limit

        p.TotalRows = int(totalRows)
        p.TotalPages = int(math.Ceil(float64(totalRows) / float64(p.Limit)))
        return func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                return db.Limit(p.Limit).Offset(offset)
        }</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package errs

import "gorm.io/gorm"

type ErrorType uint64

type ErrorDebugResponse struct {
        Message string `json:"message"`
        File    string `json:"file"`
}

type errCustom struct {
        Message string    `json:"message"`
        Err     error     `json:"error"`
        Type    ErrorType `json:"type"`
        File    string    `json:"file"`
        Stack   string    `json:"stack-trace"`
}

func (msg errCustom) GetMessage() string <span class="cov0" title="0">{
        return msg.Message
}</span>

func (msg errCustom) Error() string <span class="cov8" title="1">{
        if msg.Message != "" </span><span class="cov0" title="0">{
                return msg.Message + ": " + msg.Err.Error()
        }</span>
        <span class="cov8" title="1">return msg.Err.Error()</span>
}

func (msg errCustom) GetErr() error <span class="cov0" title="0">{
        return msg.Err
}</span>

func (msg errCustom) GetFile() string <span class="cov0" title="0">{
        return msg.File
}</span>

func (msg errCustom) GetStack() string <span class="cov0" title="0">{
        return msg.Stack
}</span>

func (msg errCustom) GetErrorType() ErrorType <span class="cov0" title="0">{
        return msg.Type
}</span>

func (msg errCustom) IsErrNoRows() bool <span class="cov0" title="0">{
        return msg.Err == gorm.ErrRecordNotFound
}</span>

func (msg *errCustom) IsType(flags ErrorType) bool <span class="cov0" title="0">{
        return msg.Type == flags
}</span>

func (msg *errCustom) UnWrap() error <span class="cov0" title="0">{
        return msg.Err
}</span>

func (msg *errCustom) GetErrorDebugResponse() *ErrorDebugResponse <span class="cov0" title="0">{
        e := ErrorDebugResponse{}

        e.Message = msg.Err.Error()
        e.File = msg.File

        return &amp;e
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package errs

import "fmt"

const (
        ErrorTypePanic               = 500
        ErrorTypeUnProcessableEntity = 422
)

func Wrap(err error) Error <span class="cov8" title="1">{
        return generateError("", err, ErrorTypeUnProcessableEntity, 3)
}</span>

func generateError(name string, err error, errType ErrorType, stackIndex int) Error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">stack, file := StackAndFile(stackIndex)
        return &amp;errCustom{
                Message: name,
                Err:     err,
                Type:    errType,
                File:    file,
                Stack:   stack,
        }</span>
}

func PanicError(name string, err error, skip int) Error <span class="cov0" title="0">{
        stack, file := StackAndFile(skip)

        if err == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("%s", name)
        }</span>

        <span class="cov0" title="0">return &amp;errCustom{
                Message: name,
                Err:     err,
                Type:    ErrorTypePanic,
                File:    file,
                Stack:   stack,
        }</span>

}
</pre>
		
		<pre class="file" id="file38" style="display: none">package errs

import (
        "bytes"
        "fmt"
        "io/ioutil"
        "runtime"
        "strings"
)

var (
        dunno      = []byte("???")
        slash      = []byte("/")
        dot        = []byte(".")
        centerDot  = []byte(".")
        pathPrefix = "/go/src/github.com/ZinedineR/moodle-api"
)

func StackAndFile(skip int) (string, string) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        var (
                lines     [][]byte
                lastFile  string
                firstFile string
        )

        for i := skip; ; i++ </span><span class="cov8" title="1">{
                pc, file, line, ok := runtime.Caller(i)
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if firstFile == "" </span><span class="cov8" title="1">{
                        firstFile = strings.ReplaceAll(fmt.Sprintf("%s:%d", file, line), pathPrefix, "...")
                }</span>

                <span class="cov8" title="1">if strings.Contains(file, "gin-gonix/gin@v1.4.0/context.go") ||
                        strings.Contains(file, "net/http/server.go") </span><span class="cov0" title="0">{

                        break</span>
                }

                <span class="cov8" title="1">fmt.Fprintf(buf, "%s:%d\n", file, line)
                if file != lastFile </span><span class="cov8" title="1">{
                        data, err := ioutil.ReadFile(file)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">lines = bytes.Split(data, []byte{'\n'})
                        lastFile = file</span>
                }
                <span class="cov8" title="1">fmt.Fprintf(buf, "\t%s: %s\n", function(pc), source(lines, line))</span>
        }

        <span class="cov8" title="1">return strings.ReplaceAll(buf.String(), pathPrefix, "..."), firstFile</span>

}

func function(pc uintptr) []byte <span class="cov8" title="1">{
        fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov0" title="0">{
                return dunno
        }</span>
        <span class="cov8" title="1">name := []byte(fn.Name())

        if lastSlash := bytes.LastIndex(name, slash); lastSlash &gt;= 0 </span><span class="cov8" title="1">{
                name = name[lastSlash+1:]
        }</span>
        <span class="cov8" title="1">if period := bytes.Index(name, dot); period &gt;= 0 </span><span class="cov8" title="1">{
                name = name[period+1:]
        }</span>
        <span class="cov8" title="1">name = bytes.Replace(name, centerDot, dot, -1)
        return name</span>
}

func source(lines [][]byte, n int) []byte <span class="cov8" title="1">{
        n--

        if n &lt; 0 || n &gt;= len(lines) </span><span class="cov0" title="0">{
                return dunno
        }</span>

        <span class="cov8" title="1">return bytes.TrimSpace(lines[n])</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package exception

// Code is a type alias for string, representing the error code of an exception.
type Code string

// Predefined error codes.
const (
        InvalidArgumentCode  Code = "INVALID_ARGUMENT"  // Represents an invalid argument error.
        NotFoundCode         Code = "NOT_FOUND"         // Represents a not found error.
        AlreadyExistsCode    Code = "ALREADY_EXISTS"    // Represents an already exists error.
        PermissionDeniedCode Code = "PERMISSION_DENIED" // Represents a permission denied error.
        UnauthenticatedCode  Code = "UNAUTHENTICATED"   // Represents an unauthenticated error.
        InternalErrorCode    Code = "INTERNAL"          // Represents an internal error.
)

// Exception is a struct to represent exception/error from service.
// Code is the error code of the exception.
// Message is the error message of the exception.
// Error is the original error that caused the exception, if any.
type Exception struct {
        Code    Code
        Message any
        Error   error
}

// InvalidArgument creates a new Exception with the InvalidArgumentCode error code.
func InvalidArgument(message any) *Exception <span class="cov8" title="1">{
        return &amp;Exception{
                Code:    InvalidArgumentCode,
                Message: message,
        }
}</span>

// NotFound creates a new Exception with the NotFoundCode error code.
func NotFound(message any) *Exception <span class="cov8" title="1">{
        return &amp;Exception{
                Code:    NotFoundCode,
                Message: message,
        }
}</span>

// AlreadyExists creates a new Exception with the AlreadyExistsCode error code.
func AlreadyExists(message any) *Exception <span class="cov0" title="0">{
        return &amp;Exception{
                Code:    AlreadyExistsCode,
                Message: message,
        }
}</span>

// PermissionDenied creates a new Exception with the PermissionDeniedCode error code.
func PermissionDenied(message any) *Exception <span class="cov8" title="1">{
        return &amp;Exception{
                Code:    PermissionDeniedCode,
                Message: message,
        }
}</span>

// Unauthenticated creates a new Exception with the UnauthenticatedCode error code.
func Unauthenticated(message any) *Exception <span class="cov0" title="0">{
        return &amp;Exception{
                Code:    UnauthenticatedCode,
                Message: message,
        }
}</span>

// Internal creates a new Exception with the InternalErrorCode error code.
// The original error that caused the exception is also included.
func Internal(message any, err error) *Exception <span class="cov8" title="1">{
        return &amp;Exception{
                Code:    InternalErrorCode,
                Message: message,
                Error:   err,
        }
}</span>

// Conflict creates a new Exception with the AlreadyExistsCode error code.
func Conflict(message any) *Exception <span class="cov0" title="0">{
        return &amp;Exception{
                Code:    AlreadyExistsCode,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package filelog

import (
        "fmt"
        "log"
        "os"
        "time"
)

func LogToFile(errorMessage string, request interface{}) <span class="cov0" title="0">{
        logPath := os.Getenv("LOG_PATH")
        currentTime := time.Now().Format(time.RFC3339)
        logMessage := fmt.Sprintf("Time: %s\nError: %s\nRequest: %+v\n---------------------------------------------------------------------------\n\n", currentTime, errorMessage, request)
        file, err := os.OpenFile(logPath+"logs.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        if _, err := file.WriteString(logMessage); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to write to log file: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package filevalidation

import (
        "bufio"
        "encoding/base64"
        "errors"
        "github.com/gabriel-vasile/mimetype"
        "io"
        "log/slog"
        "os"
)

func ValidateImage(base64String string, maxsize int64) (string, error) <span class="cov0" title="0">{
        // Decode the base64 string to bytes
        data, err := base64.StdEncoding.DecodeString(base64String)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get the size of the decoded data
        <span class="cov0" title="0">fileSize := int64(len(data))

        // Check if the file size exceeds the maximum allowed size
        if fileSize &gt; maxsize </span><span class="cov0" title="0">{
                return "", errors.New("file size exceeds the maximum allowed size")
        }</span>

        // Detect mimeType
        <span class="cov0" title="0">mimeType := mimetype.Detect(data)

        // Extension or mimeType checker, if not .png/.jpeg/.webp/.bmp return error
        if mimeType.String() != "image/png" &amp;&amp; mimeType.String() != "image/jpeg" &amp;&amp; mimeType.String() != "image/vnd.mozilla.apng" &amp;&amp; mimeType.String() != "image/webp" &amp;&amp; mimeType.String() != "image/bmp" </span><span class="cov0" title="0">{
                return "", errors.New("extension invalid: " + mimeType.String())
        }</span>

        <span class="cov0" title="0">return mimeType.Extension(), nil</span>
}

func LoadImage64(filePath string, filename string) (string, error) <span class="cov0" title="0">{
        // Open file on disk.
        file, err := os.Open(filePath + filename)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(err.Error())
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Read entire JPG into byte slice.
        reader := bufio.NewReader(file)
        content, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(err.Error())
                return "", err
        }</span>

        // Encode as base64.
        <span class="cov0" title="0">encoded := base64.StdEncoding.EncodeToString(content)
        return encoded, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package getfilter

import "strings"

func GenerateWhere(filter FilterItem) []interface{} <span class="cov0" title="0">{
        keySearch := strings.ToLower(filter.Value)
        var keyList []interface{}

        if filter.Operator == "like" </span><span class="cov0" title="0">{
                keyList = make([]interface{}, 1)
                keyList[0] = "%" + keySearch + "%"
        }</span> else<span class="cov0" title="0"> if filter.Operator == "in" </span><span class="cov0" title="0">{
                keys := strings.Split(keySearch, ",")
                keyList = make([]interface{}, len(keys))
                for i, key := range keys </span><span class="cov0" title="0">{
                        keyList[i] = key
                }</span>
        } else<span class="cov0" title="0"> {
                keyList = make([]interface{}, 1)
                keyList[0] = keySearch
        }</span>
        <span class="cov0" title="0">return keyList</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package getfilter

import "regexp"

type QueryField struct {
        Operator string
        Value    string
}

func ArrQuery(queryString string) map[string]QueryField <span class="cov0" title="0">{
        regex := regexp.MustCompile(`(\w+):([^|]+):(\w+)`)
        matches := regex.FindAllStringSubmatch(queryString, -1)

        arrQuery := make(map[string]QueryField)

        for _, match := range matches </span><span class="cov0" title="0">{
                field := match[1]
                value := match[2]
                operator := match[3]

                symbol, exists := QueryParserOperators[operator]
                if !exists </span><span class="cov0" title="0">{
                        symbol = operator
                }</span>

                <span class="cov0" title="0">arrQuery[field] = QueryField{
                        Operator: symbol,
                        Value:    value,
                }</span>
        }

        <span class="cov0" title="0">return arrQuery</span>
}

func ArrSort(queryString string) map[string]QueryField <span class="cov0" title="0">{
        regex := regexp.MustCompile(`(\w+):([^|]+)`)
        matches := regex.FindAllStringSubmatch(queryString, -1)

        arrSort := make(map[string]QueryField)

        for _, match := range matches </span><span class="cov0" title="0">{
                field := match[1]
                value := match[2]

                arrSort[field] = QueryField{
                        Operator: field,
                        Value:    value,
                }
        }</span>

        <span class="cov0" title="0">return arrSort</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package getfilter

import (
        "github.com/gin-gonic/gin"
)

type FilterItem struct {
        Field    string `json:"field"`
        Operator string `json:"operator"`
        Value    string `json:"value"`
}

type FilterSort struct {
        Field string `json:"field"`
        Value string `json:"value"`
}

type FilterMiddleware struct {
        ArrQuery []FilterItem
        ArrSort  []FilterSort
        Message  string
}

func Initiate(c *gin.Context) *FilterMiddleware <span class="cov0" title="0">{
        filtermiddleware := &amp;FilterMiddleware{}

        filter, exists := c.GetQuery("filter")
        if exists </span><span class="cov0" title="0">{
                filterItems := make([]FilterItem, 0)
                for field, q := range ArrQuery(filter) </span><span class="cov0" title="0">{
                        filterItems = append(filterItems, FilterItem{
                                Field:    field,
                                Operator: q.Operator,
                                Value:    q.Value,
                        })
                }</span>
                <span class="cov0" title="0">filtermiddleware.ArrQuery = filterItems</span>
        }
        <span class="cov0" title="0">sort, exists := c.GetQuery("sort")
        if exists </span><span class="cov0" title="0">{
                filterSort := make([]FilterSort, 0)
                for field, q := range ArrSort(sort) </span><span class="cov0" title="0">{
                        filterSort = append(filterSort, FilterSort{
                                Field: field,
                                Value: q.Value,
                        })
                }</span>
                <span class="cov0" title="0">filtermiddleware.ArrSort = filterSort</span>
        }

        <span class="cov0" title="0">return filtermiddleware</span>
}

func Validation(query *FilterMiddleware) bool <span class="cov0" title="0">{
        for _, item := range query.ArrQuery </span><span class="cov0" title="0">{
                if !contains(item.Operator, QueryParserSymbols) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func Handle(c *gin.Context) bool <span class="cov0" title="0">{
        if Validation(Initiate(c)) </span><span class="cov0" title="0">{
                c.Set("ArrQuery", Initiate(c).ArrQuery)
                c.Set("ArrSort", Initiate(c).ArrSort)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func contains(item string, arr []string) bool <span class="cov0" title="0">{
        for _, v := range arr </span><span class="cov0" title="0">{
                if v == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package httpclient

import (
        "bytes"
        "encoding/json"
        "fmt"
        "github.com/pkg/errors"
        "github.com/sirupsen/logrus"
        "io"
        "net/http"
        "strings"
)

// New creates client Factory
func New() ClientFactory <span class="cov0" title="0">{
        return &amp;clientFactory{}
}</span>

// ClientFactory creates specific client implementation
type ClientFactory interface {
        CreateClient() Client
}

type clientFactory struct{}

func (c *clientFactory) CreateClient() Client <span class="cov0" title="0">{
        return &amp;client{}
}</span>

// Client abstracts third party request client
type Client interface {
        Get(string, map[string]string, interface{}) (int, error)
        PostJSON(string, interface{}, map[string]string, interface{}) (int, error)
        PutJSON(string, interface{}, map[string]string, interface{}) (int, error)
        DeleteJSON(string, map[string]string) (int, error)
        PostJSONCallback(string, interface{}, map[string]string, interface{}, string) (int, error)
}

type client struct{}

//func (c *client) PostJSON(url string, payload interface{}, headers map[string]string, dest interface{}) (int, error) {
//        payloadBytes, err := json.Marshal(payload)
//        if err != nil {
//                return http.StatusInternalServerError, errors.Wrap(err, "error while encoding JSON payload")
//        }
//
//        req, err := http.NewRequest("POST", url, strings.NewReader(string(payloadBytes)))
//        if err != nil {
//                return http.StatusInternalServerError, errors.Wrap(err, "error creating HTTP request")
//        }
//
//        for k, v := range headers {
//                req.Header.Set(k, v)
//        }
//
//        client := http.Client{}
//        resp, err := client.Do(req)
//        if err != nil {
//                return http.StatusInternalServerError, errors.Wrap(err, "error sending HTTP request")
//        }
//        defer resp.Body.Close()
//
//        bodyBytes, err := io.ReadAll(resp.Body)
//        if err != nil {
//                return resp.StatusCode, errors.Wrap(err, "error reading response body")
//        }
//
//        if len(bodyBytes) == 0 &amp;&amp; resp.StatusCode == http.StatusOK {
//                return resp.StatusCode, nil
//        }
//
//        if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil {
//                return resp.StatusCode, errors.Wrap(err, "error while decoding response content")
//        }
//
//        if resp.StatusCode != http.StatusOK {
//                return resp.StatusCode, errors.New("failed to request")
//        }
//
//        return resp.StatusCode, nil
//}

func (c client) PostJSON(url string, payload interface{}, headers map[string]string, dest interface{}) (
        statusCode int, err error,
) <span class="cov0" title="0">{
        // Convert payload to JSON
        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Set headers
        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Perform the HTTP request
        <span class="cov0" title="0">client := &amp;http.Client{}
        //client.Transport = &amp;http.Transport{
        //        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
        //}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        // Read the response body as a string
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, err
        }</span>
        // Decode the response JSON into the provided destination struct
        <span class="cov0" title="0">if err := json.Unmarshal(body, &amp;dest); err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.New(string(body[:]))
        }</span>
        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}

func (c client) PutJSON(url string, payload interface{}, headers map[string]string, dest interface{}) (
        statusCode int, err error,
) <span class="cov0" title="0">{
        // Convert payload to JSON
        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Set headers
        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Perform the HTTP request
        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read the response body as a string
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, err
        }</span>

        // Decode the response JSON into the provided destination struct
        <span class="cov0" title="0">if err := json.Unmarshal(body, &amp;dest); err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.New(string(body[:]))
        }</span>

        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}

func (c client) DeleteJSON(url string, headers map[string]string) (
        statusCode int, err error,
) <span class="cov0" title="0">{
        // Create HTTP request
        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Set headers
        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Perform the HTTP request
        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read the response body as a string
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.New(string(body[:]))
        }</span>

        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}

func (c *client) PostJSONCallback(
        url string, payload interface{}, headers map[string]string, dest interface{}, apiRequestId string,
) (int, error) <span class="cov0" title="0">{
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, errors.Wrap(err, "error while encoding JSON payload")
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, strings.NewReader(string(payloadBytes)))
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, errors.Wrap(err, "error creating HTTP request")
        }</span>

        <span class="cov0" title="0">for k, v := range headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov0" title="0">client := http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, errors.Wrap(err, "error sending HTTP request")
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        bodyBytes, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.Wrap(err, "error reading response body")
        }</span>

        <span class="cov0" title="0">logrus.Infoln(fmt.Sprintf("REQUEST ID: %s , RESPONSE CODE CALLBACK: %v", apiRequestId, resp.StatusCode))
        if len(bodyBytes) == 0 &amp;&amp; resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                return resp.StatusCode, nil
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.Wrap(err, "error while decoding response content")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.New("failed to request")
        }</span>

        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}

func (c *client) Get(url string, headers map[string]string, dest interface{}) (
        int, error,
) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, errors.Wrap(err, "error creating HTTP request")
        }</span>

        <span class="cov0" title="0">for k, v := range headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov0" title="0">client := http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, errors.Wrap(err, "error sending HTTP request")
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        bodyBytes, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.Wrap(err, "error reading response body")
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(bodyBytes, &amp;dest); err != nil </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.Wrap(err, "error while decoding response content :"+string(bodyBytes[:]))
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return resp.StatusCode, errors.New("failed to request")
        }</span>

        <span class="cov0" title="0">return resp.StatusCode, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package httputils

import (
        "bytes"
        "context"
        "fmt"
        "net/http"
)

// DoHttpRequest is a function that sends an HTTP request.
// It accepts the HTTP method, target URL, headers, and data as parameters.
// It creates a new HTTP client and a new HTTP request with the provided parameters.
// If there is an error while creating the request, it returns nil and the error.
// It then sets the headers for the request.
// It sends the request and returns the response and any error that occurred.
// If there is an error while sending the request, it returns nil and the error.
func DoHttpRequest(ctx context.Context, method string, target string, headers map[string]any, data []byte) (*http.Response, error) <span class="cov0" title="0">{
        client := &amp;http.Client{}
        req, err := http.NewRequestWithContext(ctx, method, target, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, fmt.Sprint(value))
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package httputils

import "boiler-plate/pkg/exception"

// ErrorResponse is a struct to represent error http response
type ErrorResponse struct {
        StatusCode  int    `json:"status_code"`
        Message     any    `json:"message"`
        DetailError string `json:"error,omitempty"`
}

func (r *ErrorResponse) Error() string <span class="cov0" title="0">{
        return r.DetailError
}</span>

// GenErrorResponse is a function to generate error http response
func GenErrorResponse(statusCode int, message any, err error) *ErrorResponse <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return &amp;ErrorResponse{
                        StatusCode: statusCode,
                        Message:    message,
                }
        }</span>
        <span class="cov8" title="1">return &amp;ErrorResponse{
                StatusCode:  statusCode,
                Message:     message,
                DetailError: err.Error(),
        }</span>
}

// GenErrorResponseException is a function to generate error response from exception
func GenErrorResponseException(exc *exception.Exception) *ErrorResponse <span class="cov8" title="1">{
        switch exc.Code </span>{
        case exception.InvalidArgumentCode:<span class="cov8" title="1">
                return GenErrorResponse(400, exc.Message, exc.Error)</span>
        case exception.NotFoundCode:<span class="cov8" title="1">
                return GenErrorResponse(404, exc.Message, exc.Error)</span>
        case exception.AlreadyExistsCode:<span class="cov0" title="0">
                return GenErrorResponse(409, exc.Message, exc.Error)</span>
        case exception.PermissionDeniedCode:<span class="cov0" title="0">
                return GenErrorResponse(403, exc.Message, exc.Error)</span>
        case exception.UnauthenticatedCode:<span class="cov0" title="0">
                return GenErrorResponse(401, exc.Message, exc.Error)</span>
        case exception.InternalErrorCode:<span class="cov8" title="1">
                return GenErrorResponse(500, exc.Message, exc.Error)</span>
        default:<span class="cov0" title="0">
                return GenErrorResponse(500, exc.Message, exc.Error)</span>
        }
}

type ExceptionResponse struct {
        StatusCode int `json:"status_code"`
        Message    any `json:"message"`
}

type SuccessResponse struct {
        StatusCode int    `json:"status_code"`
        Message    string `json:"message"`
}

type DataSuccessResponse struct {
        StatusCode int    `json:"status_code"`
        Message    string `json:"message"`
        Data       any    `json:"data"`
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package memstorage

import (
        "sync"
        "time"
)

// item represents a cache item with a value and an expiration time.
type item[V any] struct {
        value  V
        expiry time.Time
}

// isExpired checks if the cache item has expired.
func (i item[V]) isExpired() bool <span class="cov0" title="0">{
        return time.Now().After(i.expiry)
}</span>

// MemStorage is a generic cache implementation with support for time-to-live
// (TTL) expiration.
type MemStorage[K comparable, V any] struct {
        items map[K]item[V] // The map storing cache items.
        mu    sync.Mutex    // Mutex for controlling concurrent access to the cache.
}

// NewMemStorage creates a new MemStorage instance and starts a goroutine to periodically
// remove expired items every 5 seconds.
func NewMemStorage[K comparable, V any]() *MemStorage[K, V] <span class="cov0" title="0">{
        c := &amp;MemStorage[K, V]{
                items: make(map[K]item[V]),
        }

        go func() </span><span class="cov0" title="0">{
                for range time.Tick(5 * time.Second) </span><span class="cov0" title="0">{
                        c.mu.Lock()

                        // Iterate over the cache items and delete expired ones.
                        for key, item := range c.items </span><span class="cov0" title="0">{
                                if item.isExpired() </span><span class="cov0" title="0">{
                                        delete(c.items, key)
                                }</span>
                        }

                        <span class="cov0" title="0">c.mu.Unlock()</span>
                }
        }()

        <span class="cov0" title="0">return c</span>
}

// Set adds a new item to the cache with the specified key, value, and
// time-to-live (TTL).
func (c *MemStorage[K, V]) Set(key K, value V, ttl time.Duration) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.items[key] = item[V]{
                value:  value,
                expiry: time.Now().Add(ttl),
        }
}</span>

// Get retrieves the value associated with the given key from the cache.
func (c *MemStorage[K, V]) Get(key K) (V, bool) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        item, found := c.items[key]
        if !found </span><span class="cov0" title="0">{
                // If the key is not found, return the zero value for V and false.
                return item.value, false
        }</span>

        <span class="cov0" title="0">if item.isExpired() </span><span class="cov0" title="0">{
                // If the item has expired, remove it from the cache and return the
                // value and false.
                delete(c.items, key)
                return item.value, false
        }</span>

        // Otherwise return the value and true.
        <span class="cov0" title="0">return item.value, true</span>
}

// Remove removes the item with the specified key from the cache.
func (c *MemStorage[K, V]) Remove(key K) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Delete the item with the given key from the cache.
        delete(c.items, key)
}</span>

// Pop removes and returns the item with the specified key from the cache.
func (c *MemStorage[K, V]) Pop(key K) (V, bool) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        item, found := c.items[key]
        if !found </span><span class="cov0" title="0">{
                // If the key is not found, return the zero value for V and false.
                return item.value, false
        }</span>

        // If the key is found, delete the item from the cache.
        <span class="cov0" title="0">delete(c.items, key)

        if item.isExpired() </span><span class="cov0" title="0">{
                // If the item has expired, return the value and false.
                return item.value, false
        }</span>

        // Otherwise return the value and true.
        <span class="cov0" title="0">return item.value, true</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package migration

import (
        submissionDomain "boiler-plate/internal/submissions/domain"
        "boiler-plate/internal/users/domain"
        "fmt"
        "github.com/sirupsen/logrus"
        "gorm.io/gorm"
        "sort"
)

func Initmigrate(db *gorm.DB) <span class="cov0" title="0">{

        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                defer sqlDB.Close()
        }</span>

        <span class="cov0" title="0">executePendingMigrations(db)

        // Migrate rest of the models
        logrus.Println(fmt.Println("AutoMigrate Model [table_name]"))
        db.AutoMigrate(&amp;domain.Users{})
        logrus.Infoln(fmt.Println("  TableModel [" +
                (&amp;domain.Users{}).TableName() + "]"))
        db.AutoMigrate(&amp;submissionDomain.Submissions{})
        logrus.Infoln(fmt.Println("  TableModel [" +
                (&amp;submissionDomain.Submissions{}).TableName() + "]"))</span>
}

func executePendingMigrations(db *gorm.DB) <span class="cov0" title="0">{
        db.AutoMigrate(&amp;MigrationHistoryModel{})
        lastMigration := MigrationHistoryModel{}
        skipMigration := db.Order("migration_id desc").Limit(1).Find(&amp;lastMigration).RowsAffected &gt; 0

        // skip to last migration
        keys := make([]string, 0, len(migrations))
        for k := range migrations </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        // run all migrations in one transaction
        if len(migrations) == 0 </span><span class="cov0" title="0">{
                logrus.Infoln(fmt.Print("No pending migrations"))
        }</span> else<span class="cov0" title="0"> {
                db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        for _, k := range keys </span><span class="cov0" title="0">{
                                if skipMigration </span><span class="cov0" title="0">{
                                        if k == lastMigration.MigrationID </span><span class="cov0" title="0">{
                                                skipMigration = false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logrus.Infoln(fmt.Sprintf("  " + k))
                                        tx.Transaction(func(subTx *gorm.DB) error </span><span class="cov0" title="0">{
                                                // run migration update
                                                checkError(migrations[k](subTx))
                                                // insert migration id into history
                                                checkError(subTx.Create(MigrationHistoryModel{MigrationID: k}).Error)
                                                return nil
                                        }</span>)
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                })
        }
}

type mFunc func(tx *gorm.DB) error

var migrations = make(map[string]mFunc)

// MigrationHistoryModel model migration
type MigrationHistoryModel struct {
        MigrationID string `gorm:"primaryKey"`
}

// TableName name of migration table
func (model *MigrationHistoryModel) TableName() string <span class="cov0" title="0">{
        return "migration_history"
}</span>

func checkError(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                logrus.Infoln(fmt.Print(err.Error()))
                panic(err)</span>
        }
}

// func registerMigration(id string, fm mFunc) {
//         migrations[id] = fm
// }
</pre>
		
		<pre class="file" id="file50" style="display: none">package password

import "golang.org/x/crypto/bcrypt"

func CheckPassword(hashPassword, password string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hashPassword), []byte(password))
        return err == nil
}</span>

func HashPassword(password string) string <span class="cov0" title="0">{
        passwordHash, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(passwordHash)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package responsehelper

import (
        "boiler-plate/internal/base/domain"
)

func GetStatusResponse(statusCode int, description string) *domain.Status <span class="cov0" title="0">{
        switch statusCode </span>{
        case 200:<span class="cov0" title="0">
                return &amp;domain.Status{
                        ResponseCode:    statusCode,
                        ResponseMessage: "Successful",
                }</span>

        case 500:<span class="cov0" title="0">
                return &amp;domain.Status{
                        ResponseCode:    statusCode,
                        ResponseMessage: "service unavailable",
                }</span>

        }

        <span class="cov0" title="0">return &amp;domain.Status{
                ResponseCode:    statusCode,
                ResponseMessage: description,
        }</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package server

import "boiler-plate/app/appconf"

type App interface {
        Run(config *appconf.Config) error
}

type LogMessage struct {
        CompanyID  int64
        EmployeeID int64
        Email      string
        Log        string
}

const (
        DefaultResponseType = iota // For API
        StreamResponseType         // For Excel
)

type ResponseInterface struct {
        Status int         `json:"status"`
        Data   interface{} `json:"data"`
}

type Response struct {
        Status       int         `json:"status"`
        Message      string      `json:"message"`
        Data         interface{} `json:"data"`
        RequestID    string      `json:"request_id"`
        StackTrace   string      `json:"-"`
        Log          *LogMessage `json:"-"`
        ResponseType int         `json:"-"`
}

type ResponseSignature struct {
        Signature string `json:"signature"`
}

func (r Response) GetStatus() int <span class="cov0" title="0">{
        return r.Status

}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package network

import (
        "log/slog"
        "net"
)

// GetLocalIP retrieves the local IP address of the machine by dialing a network connection to a remote server.
// It uses UDP protocol to dial the given server address and retrieves the local IP address from the local address of the connection.
//
// Example usage:
//
//        host := "0.0.0.0"
//        if ip, err := GetLocalIP(); err == nil {
//            host = ip.String()
//        }
//
//        fmt.Println(host)
//
// Returns the local IP address as a net.IP and any error that occurred during the network dialing operation.
const DefaultIP = "0.0.0.0"

func GetLocalIP() (net.IP, error) <span class="cov0" title="0">{
        conn, err := net.Dial("udp", "8.8.8.8:80")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func(conn net.Conn) </span><span class="cov0" title="0">{
                err := conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("error closing network connection", "error", err.Error())
                }</span>
        }(conn)

        <span class="cov0" title="0">localAddress := conn.LocalAddr().(*net.UDPAddr)

        return localAddress.IP, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package phonenumber

import (
        "log/slog"

        "github.com/nyaruka/phonenumbers"
)

type RegionCode string

const (
        RegionCodeMalaysia  RegionCode = "MY"
        RegionCodeIndonesia RegionCode = "ID"
)

type PhoneNumber struct {
        number *phonenumbers.PhoneNumber
}

func NewPhoneNumber(number string, regionCode RegionCode) (*PhoneNumber, error) <span class="cov0" title="0">{
        parse, err := phonenumbers.Parse(number, string(regionCode))
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to parse phone number", "error", err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;PhoneNumber{number: parse}, nil</span>
}

func (p *PhoneNumber) String() string <span class="cov0" title="0">{
        return phonenumbers.Format(p.number, phonenumbers.E164)[1:]
}</span>

func (p *PhoneNumber) E164() string <span class="cov0" title="0">{
        return phonenumbers.Format(p.number, phonenumbers.E164)
}</span>

func (p *PhoneNumber) National() string <span class="cov0" title="0">{
        return phonenumbers.Format(p.number, phonenumbers.NATIONAL)
}</span>

func (p *PhoneNumber) International() string <span class="cov0" title="0">{
        return phonenumbers.Format(p.number, phonenumbers.INTERNATIONAL)
}</span>

func (p *PhoneNumber) IsValid() bool <span class="cov0" title="0">{
        return phonenumbers.IsValidNumber(p.number)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package pointer

import (
        "fmt"
        "time"
)

// String function takes any type of data and returns a pointer to a string if the data is not nil.
// If the data is nil, it returns nil.
func String(data any) *string <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                v := data.(string)
                return &amp;v
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DefaultString function takes any type of data and returns a string if the data is not nil.
// If the data is nil, it returns an empty string.
func DefaultString(data any) string <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                v := data.(string)
                return v
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Time function takes any type of data and returns a pointer to a time.Time if the data is not nil.
// If the data is nil, it returns nil.
func Time(data any) *time.Time <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                v := data.(time.Time)
                return &amp;v
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Int function takes any type of data and returns a pointer to an int if the data is not nil.
// If the data is nil, it returns nil.
func Int(data any) *int <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                v := data.(int)
                return &amp;v
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Int64 function takes any type of data and returns a pointer to an int64 if the data is not nil.
// If the data is nil, it returns nil.
func Int64(data any) *int64 <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                v := data.(int64)
                return &amp;v
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Float64 function takes any type of data and returns a pointer to a float64 if the data is not nil.
// If the data is nil, it returns nil.
func Float64(data any) *float64 <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                v := data.(float64)
                return &amp;v
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Float64ToString function takes any type of data and returns a pointer to a string representation of a float64 if the data is not nil.
// If the data is nil, it returns nil.
func Float64ToString(data any) *string <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                v := fmt.Sprint(data.(float64))
                return &amp;v
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Bool function takes any type of data and returns a pointer to a bool if the data is not nil.
// If the data is nil, it returns nil.
func Bool(data any) *bool <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                v := data.(bool)
                return &amp;v
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DefaultBool function takes any type of data and returns a bool if the data is not nil.
// If the data is nil, it returns false.
func DefaultBool(data any) bool <span class="cov0" title="0">{
        if data != nil </span><span class="cov0" title="0">{
                return data.(bool)
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package rand

import gonanoid "github.com/matoous/go-nanoid/v2"

func Generate(rawAlphabet string, size int, prefix ...string) (string, error) <span class="cov0" title="0">{
        r, e := gonanoid.Generate(rawAlphabet, size)
        if e != nil </span><span class="cov0" title="0">{
                return "", e
        }</span>
        <span class="cov0" title="0">if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                return prefix[0] + r, nil
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func GenerateNumeric(size int, prefix ...string) (string, error) <span class="cov0" title="0">{
        r, e := gonanoid.Generate("123456789", size)
        if e != nil </span><span class="cov0" title="0">{
                return "", e
        }</span>
        <span class="cov0" title="0">if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                return prefix[0] + r, nil
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package text

import (
        "strconv"
        "strings"
)

// Abbreviate is a function that takes a sentence as a string and returns a string.
// The returned string is an abbreviation of the input sentence, where each word in the sentence is abbreviated to its first character.
// If the sentence is empty or contains only spaces, the function returns an empty string.
func Abbreviate(sentence string) string <span class="cov0" title="0">{
        words := strings.Split(sentence, " ")
        var result string
        for _, word := range words </span><span class="cov0" title="0">{
                if len(word) != 0 </span><span class="cov0" title="0">{
                        result += string(word[0])
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func StrToInt(idString string) (int64, error) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(idString, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package xvalidator

import (
        "fmt"
        "log/slog"
        "reflect"

        "github.com/go-playground/validator/v10"
        "github.com/nyaruka/phonenumbers"
)

// Validator is a struct that contains a pointer to a validator.Validate instance.
type Validator struct {
        validate *validator.Validate
}

// NewValidator is a function that initializes a new Validator instance.
// It registers a tag name function that returns the "name" tag of a struct field.
// It logs that the validator has been initialized and returns the new Validator instance.
func NewValidator() *Validator <span class="cov0" title="0">{
        validate := validator.New()
        validate.RegisterTagNameFunc(func(field reflect.StructField) string </span><span class="cov0" title="0">{
                return field.Tag.Get("name")
        }</span>)

        <span class="cov0" title="0">validate.RegisterValidation("phone", func(fl validator.FieldLevel) bool </span><span class="cov0" title="0">{
                phoneNumber := fl.Field().String()

                phoneString, err := phonenumbers.Parse(phoneNumber, "MY")
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return phonenumbers.IsValidNumber(phoneString)</span>
        })

        <span class="cov0" title="0">validate.RegisterValidation("email_if_type", func(fl validator.FieldLevel) bool </span><span class="cov0" title="0">{
                typeField := fl.Parent().FieldByName("Type").String()
                emailField := fl.Field().String()
                if typeField == "email" </span><span class="cov0" title="0">{
                        if err := validator.New().Var(emailField, "email"); err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">validate.RegisterValidation("phone_if_type", func(fl validator.FieldLevel) bool </span><span class="cov0" title="0">{
                typeField := fl.Parent().FieldByName("Type").String()
                phoneNumber := fl.Field().String()

                if typeField == "phone_number" </span><span class="cov0" title="0">{
                        phoneString, err := phonenumbers.Parse(phoneNumber, "MY")
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">return phonenumbers.IsValidNumber(phoneString)</span>
                }
                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">slog.Info("validator initialized")
        return &amp;Validator{validate: validate}</span>
}

// Struct is a method of the Validator struct that validates a struct.
// It returns a slice of strings containing the validation errors.
// If there are no validation errors, it returns nil.
func (v *Validator) Struct(s interface{}) map[string]string <span class="cov0" title="0">{
        err := v.validate.Struct(s)
        if err != nil </span><span class="cov0" title="0">{
                return v.formatValidationError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Var is a method of the Validator struct that validates a single variable.
// It returns a slice of strings containing the validation errors.
// If there are no validation errors, it returns nil.
func (v *Validator) Var(field interface{}, tag string) map[string]string <span class="cov0" title="0">{
        err := v.validate.Var(field, tag)
        if err != nil </span><span class="cov0" title="0">{
                return v.formatValidationError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// formatValidationError is a method of the Validator struct that formats validation errors.
// It returns a slice of strings containing the formatted validation errors.
func (v *Validator) formatValidationError(err error) map[string]string <span class="cov0" title="0">{
        errors := make(map[string]string)
        for _, err := range err.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                switch err.Tag() </span>{
                case "required":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s is required", err.Field())</span>
                case "email":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s is not a valid email", err.Field())</span>
                case "min":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be at least %s", err.Field(), err.Param())</span>
                case "max":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be at most %s", err.Field(), err.Param())</span>
                case "len":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be %s characters long", err.Field(), err.Param())</span>
                case "gte":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be greater than or equal to %s", err.Field(), err.Param())</span>
                case "gt":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be greater than %s", err.Field(), err.Param())</span>
                case "lte":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be less than or equal to %s", err.Field(), err.Param())</span>
                case "lt":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be less than %s", err.Field(), err.Param())</span>
                case "numeric":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be numeric", err.Field())</span>
                case "number":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s must be a number", err.Field())</span>
                case "phone":<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s invalid phone number", err.Field())</span>
                default:<span class="cov0" title="0">
                        errors[err.Field()] = fmt.Sprintf("%s is not valid", err.Field())</span>
                }
        }
        <span class="cov0" title="0">return errors</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
